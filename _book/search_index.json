[["index.html", "Late Night Bayes Chapter 1 Welcome", " Late Night Bayes Brenden Eum 2024-10-18 Chapter 1 Welcome This is a compilation of reports that I write out of curiosity. A place to put results that I find interesting, but that I don’t feel the need to turn into a rigorous study. My data will usually come from my own studies or publicly available data. If you’re looking for code, data, or manuscripts for my papers, you can find them at the Rangel Neuroeconomics Lab or on my website. Sometimes when I have time I like to make music. The music on this home page is my own. I’ll swap the song occasionally. Feel free to shoot me an email if you have any questions or if you just want to chat (beum@caltech.edu)! "],["dcb.html", "Chapter 2 Decision Classification Boundaries 2.1 Simulated, perceptual data 2.2 Perceptual data, DDM 2.3 Perceptual data, slider 2.4 Value-based data, DDM 2.5 Value-based data, aDDM 2.6 Discussion", " Chapter 2 Decision Classification Boundaries (TL;DR) Glickman, Moran, and Usher’s (2022) Decision Classification Boundaries perform (1) outstandingly well with simulated, perceptual data; (2) decently well with impatient subjects in perceptual tasks; and (3) unsurprisingly poor with subjects in value-based tasks. This notebook is a test of the methods from (Glickman, Moran, and Usher 2022). I would like to see if their algorithm that dynamically estimates collapsing bounds (Decision Classification Boundary, DCB) works with perceptual data from an upcoming belief tracking project and value-based data from (Eum, Dolbier, and Rangel 2022). Simulated, perceptual data First, I will simulate data for two cyborgs using a DDM. Their task will be to select from two streams of rectangles whichever stream has the taller average height (see (Tsetsos et al. 2016) or (Glickman, Moran, and Usher 2022)). The first cyborg will utilize fixed decision boundaries; the second cyborg will utilize collapsing boundaries (Weibull function, per tradition). I will test if the DCB algorithm can recover the decision boundaries for both cyborgs. Real, perceptual data Second, I will use preliminary data collected for my upcoming slider task. The task is again for subjects to select from two streams of rectangles which stream has the taller average height. I think it would be interesting to see if DCB works with both (1) accumulated evidence and (2) location of the slider. Real, value-based data Third, I will read in the data from (Eum, Dolbier, and Rangel 2022). I will only use trials from the visible condition. This will be interesting since there isn’t a stream of varying evidence. It’s just a single value comparison that accumulates over time. If we use an aDDM, then there will be some variation in evidence over time based on fixation data. Here’s a quick summary of what DCB does: Discretize your time-dimension. Consider a single trial. At any time during that trial, the sequence of stimuli has provided a stream of evidence in favor of one of the actions. In the case of perceptual tasks, we can take the sum of evidence over time and come up with a metric for “accumulated evidence” at any given time point. This might be a bit trickier in value-based decision tasks. At any given point in time, agents have three potential actions (continue sampling, choose left, choose right). If we consider one point in time, then we can look at the distributions of actions along a single dimension, accumulated evidence. Each trial yields one point along this accumulated evidence dimension. The points are labeled by the action taken at that time during that trial. This allows for supervised separation by linear discriminant analysis (LDA). The boundary separation curves approximate decision boundaries over time. 2.1 Simulated, perceptual data 2.1.1 Simulate data The task is to select from two streams of rectangles the stream with the taller average height. We will generate two DDM cyborgs, the first with fixed decision bounds, the second with collapsing decision bounds. DDM function Simulate behavior for a single trial using a DDM with symmetric bounds about 0. Input: Two equal-length streams of evidence, DDM parameters. Output: A time-series of choice (0=R, 1=L, 2=continue) and accumulated evidence (scaled by drift since we are working with the DDM). DDM &lt;- function(L=c(0,0,0), R=c(0,0,0), b=0, d=.002, sig=.03, bound=c(1,1,1)) { if (length(L)!=length(R)) {stop(&quot;L and R differ in length.&quot;)} if (length(b)!=1 | length(d)!=1 | length(sig)!=1) {stop(&quot;Invalid DDM parameters.&quot;)} if (length(bound)!=length(L) &amp; length(bound)!=1) {stop(&quot;Invalid bound. Must be defined at every time point or fixed.&quot;)} if (length(bound)==1) {ub &lt;- rep(bound, length(L))} else {ub &lt;- bound} df &lt;- data.frame( sample = rep(NA, length(L)), choice = rep(NA, length(L)), ae = rep(NA, length(L)) ) RDV &lt;- b accumEvid &lt;- 0 boundaryHit &lt;- F for (t in 1:length(L)) { df$sample[t] &lt;- t RDV &lt;- RDV + d*(L[t]-R[t]) + rnorm(1, mean=0, sd=sig) accumEvid &lt;- accumEvid + d*(L[t]-R[t]) # Accumulated evidence depends on the model you&#39;re using. df$ae[t] &lt;- accumEvid df$choice[t] &lt;- 2 if (RDV&gt;=ub[t] | RDV&lt;=-ub[t]) { if (RDV&gt;=ub[t]) {df$choice[t] &lt;- 1} if (RDV&lt;=-ub[t]) {df$choice[t] &lt;- 0} boundaryHit &lt;- T break } } # if (boundaryHit==F) { #Use this to figure out which trials didn&#39;t reach a decision. # print(&quot;Decision was not reached within allotted number of samples.&quot;) # } return(df) } Trial Data This will be exactly the same for both the fixed and collapsing cyborgs. Heights will vary around 50, bounded within (0,100). All trials will favor either L or R, but the degree of difficulty may vary. set.seed(seed) nSamples = 50 nTrials = 1000 byTrial.mean = 50 byTrial.sd = 20 bySample.sd = 20 lb &lt;- 0 ub &lt;- 100 simulateData &lt;- function(nSamples,nTrials,byTrial.mean,byTrial.sd,bySample.sd,lb,ub) { simData &lt;- data.frame( trial = 1, L = rtruncnorm( nSamples, mean = rnorm(1, mean = byTrial.mean, sd = byTrial.sd), sd = bySample.sd, a = lb, b = ub ), R = rtruncnorm( nSamples, mean = rnorm(1, mean = byTrial.mean, sd = byTrial.sd), sd = bySample.sd, a = lb, b = ub ) ) for (n in 2:nTrials) { #progress(n, nTrials) #progress tracker tempData &lt;- data.frame( trial = n, L = rtruncnorm( nSamples, mean = rnorm(1, mean = byTrial.mean, sd = byTrial.sd), sd = bySample.sd, a = lb, b = ub ), R = rtruncnorm( nSamples, mean = rnorm(1, mean = byTrial.mean, sd = byTrial.sd), sd = bySample.sd, a = lb, b = ub ) ) simData &lt;- rbind(simData, tempData) } return(simData) } simData &lt;- simulateData( nSamples, nTrials, byTrial.mean, byTrial.sd, bySample.sd, lb, ub) Fixed bounds cyborg Bounds are fixed to 50 and -50 via the ‘bound’ attribute of the fixedCyborg.ddm object. set.seed(seed) fixedCyborg.ddm &lt;- list( b = 0, d = .9, sig = 4, bound = 50 ) trialData &lt;- list( L = simData$L[simData$trial==1], R = simData$R[simData$trial==1] ) fixedCyborg.data &lt;- do.call(DDM, c(trialData,fixedCyborg.ddm)) fixedCyborg.data$trial &lt;- 1 for (trial in 2:nTrials) { #progress(trial,nTrials) #progress tracker trialData &lt;- list( L = simData$L[simData$trial==trial], R = simData$R[simData$trial==trial] ) tempData &lt;- do.call(DDM, c(trialData,fixedCyborg.ddm)) tempData$trial &lt;- trial fixedCyborg.data &lt;- rbind(fixedCyborg.data, tempData) } fixedCyborg.data &lt;- na.omit(fixedCyborg.data) summary(fixedCyborg.data) ## sample choice ae trial ## Min. : 1.000 Min. :0.00 Min. :-123.9434 Min. : 1.0 ## 1st Qu.: 2.000 1st Qu.:2.00 1st Qu.: -27.4550 1st Qu.: 256.0 ## Median : 3.000 Median :2.00 Median : -0.1181 Median : 517.5 ## Mean : 4.606 Mean :1.67 Mean : 0.2420 Mean : 508.7 ## 3rd Qu.: 6.000 3rd Qu.:2.00 3rd Qu.: 28.3773 3rd Qu.: 750.8 ## Max. :33.000 Max. :2.00 Max. : 134.0897 Max. :1000.0 Collapsing bounds cyborg Bounds are decreasing as a Weibull function. Weibull parameters are taken directly from (Glickman, Moran, and Usher 2022), which I’m led to believe are taken directly from (Hawkins et al. 2015). The Weibull function is taken directly from (Hawkins et al. 2015). The scale parameter (\\(\\lambda\\)) is fixed to 4. Shape (\\(\\kappa\\)) and asymptotic convergence (\\(a&#39;\\)) can vary. set.seed(seed) weibullbound &lt;- function(t, a, k, lam, ap) { return( a-(1-exp(-(t/k)^k))*(.5*a+ap) ) } collapsingCyborg.ddm &lt;- list( b = 0, d = .9, sig = 4, bound = weibullbound(t=c(1:nSamples), a=100, k=3, lam=4, ap=10) # see Glickman et al. (2022) or Hawkins et al. (2015) ) trialData &lt;- list( L = simData$L[simData$trial==1], R = simData$R[simData$trial==1] ) collapsingCyborg.data &lt;- do.call(DDM, c(trialData,collapsingCyborg.ddm)) collapsingCyborg.data$trial &lt;- 1 for (trial in 2:nTrials) { #progress(trial,nTrials) #progress tracker trialData &lt;- list( L = simData$L[simData$trial==trial], R = simData$R[simData$trial==trial] ) tempData &lt;- do.call(DDM, c(trialData,collapsingCyborg.ddm)) tempData$trial &lt;- trial collapsingCyborg.data &lt;- rbind(collapsingCyborg.data, tempData) } collapsingCyborg.data &lt;- na.omit(collapsingCyborg.data) summary(collapsingCyborg.data) ## sample choice ae trial ## Min. : 1.000 Min. :0.000 Min. :-162.7401 Min. : 1.0 ## 1st Qu.: 2.000 1st Qu.:2.000 1st Qu.: -29.7781 1st Qu.: 234.0 ## Median : 3.000 Median :2.000 Median : 0.6016 Median : 500.0 ## Mean : 3.832 Mean :1.684 Mean : 0.7965 Mean : 496.9 ## 3rd Qu.: 5.000 3rd Qu.:2.000 3rd Qu.: 32.0336 3rd Qu.: 747.0 ## Max. :30.000 Max. :2.000 Max. : 153.0255 Max. :1000.0 2.1.2 Check behavior Fixed bounds cyborg Behavior makes sense given the decision boundaries. There is some leakage across the boundaries proportional to the variance of the noise in the DDM. Collapsing bounds cyborg Behavior makes sense given the decision boundaries. There is some leakage across the boundaries proportional to the variance of the noise in the DDM. 2.1.3 DCB DCB function Dynamically estimate collapsing decision boundaries up to a certain sample number. Input: (1) Time-series data for a single subject with trial, sample number, choice ({0,1,2} see above), and accumulated evidence. (2) Maximum sample number (since our figures only go up to 10, let’s just set this as 10 for now). Output: Time-series of the bound, over sample number dimension (time). Note that (Glickman, Moran, and Usher 2022) assumed that the collapsing bounds were symmetrical, therefore they took the average of the separating planes. DCB &lt;- function(data, maxSample) { samples &lt;- c(1:maxSample) output &lt;- data.frame( sample = samples, ub = rep(NA, length(samples)), lb = rep(NA, length(samples)), avgb = rep(NA, length(samples)) ) x_vals &lt;- data.frame(ae = seq(-150,150,1)) # resolution of the collapsing boundary for (n in samples) { #samples tryCatch({ # In some cases, there may not be any decisions for left or right when sample number is small. Don&#39;t return an error. lda.fit &lt;- lda(choice~ae, data[data$sample==n,]) lda.pred &lt;- predict(lda.fit,x_vals) #x_val closest to decision boundary for upper bound (.5 posterior probability of being choice=1 or 2) ub_x_vals &lt;- seq(0,150,1) output$ub[n] = ub_x_vals[ which(abs(lda.pred$posterior[151:301,&#39;2&#39;]-0.5)==min(abs(lda.pred$posterior[151:301,&#39;2&#39;]-0.5))) ] #x_val closest to decision boundary for lower bound (.5 posterior probability of being choice=0 or 2) lb_x_vals &lt;- seq(-150,-1,1) output$lb[n] = lb_x_vals[ which(abs(lda.pred$posterior[1:150,&#39;2&#39;]-0.5)==min(abs(lda.pred$posterior[1:150,&#39;2&#39;]-0.5))) ] output$avgb[n] = .5*(abs(output$ub[n])+abs(output$lb[n])) }, error=function(e){cat(&quot;ERROR :&quot;,conditionMessage(e), &quot;\\n&quot;)}) } return(output) } Fixed bounds cyborg The DCB isn’t perfect, but I honestly can’t deny that I’m surprised by its accuracy. Clearly it performs worse as data becomes sparse (i.e. when there are fewer choices at later times). Collapsing bounds cyborg This is where things get even more interesting. The DCB follows the collapsing bound generated by a Weibull function quite well. ## ERROR : infinite or missing values in &#39;x&#39; 2.1.4 Preliminary conclusion The DCB performs remarkably well for simulated, perceptual data where there are sequences of stimuli for each decision. There is one obvious problem at this stage. Decision boundaries cannot be estimated at a given point in time if, across all trials, all three actions are not made at that point in time. For instance, at sample 1, no choices were made for the right option; therefore, decision boundaries cannot be estimated at time \\(\\text{sample}=1\\). This prevents the DCB from estimating the starting point of decision boundaries. This seems to be the case in (Glickman, Moran, and Usher 2022) too. 2.1.5 Comparative statics Let’s see how the DCB performs when we alter some of the cyborgs’ parameters. 2.1.5.1 Fixed bounds cyborg Drift Prediction: The DCB should work fine regardless of the drift rate since accumulated evidence can be modulated by drift rate. This should also extend to attentional discounting from the aDDM with fixation data. bias = \\(0\\) noise = \\(4\\) bound = \\(\\pm 50\\) ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; Aside from the fact that all the choices are not represented at early times when drift rate is low, we see that DCB tracks the fixed boundary well for any drift rate. Noise This is important to consider since accumulated evidence can bleed over LDA boundaries. The more noise there is, the more that measurements of accumulated evidence will bleed over into other classifications. For instance, with a larger noise, there should be more “continue sampling” observations that fall above the separating plane for “choose left” and below the separating plane for “choose right”. And vice versa. Prediction: I think more noise variance will negatively affect the performance of the DCB. bias = \\(0\\) drift = \\(0.9\\) bound = \\(\\pm 50\\) As the variance of noise grows, we see the performance of DCB progressively deteriorate over time. I would imagine that this could become a huge problem in real data and might affect the robustness of this algorithm. Bounds Prediction: I think this may end up mechanically similar to changing the drift rate, so I don’t think changing the bounds will affect DCB performance. bias = \\(0\\) drift = \\(0.9\\) noise = \\(4\\) ## ERROR : infinite or missing values in &#39;x&#39; Bounds don’t seem to affect the performance of the DCB. The relatively poor performance of the DCB when bounds are large is caused by the uneven distribution of choices at early times. Early times are dominated by “continue sampling”, making it difficult for LDA to determine accurate classification bounds. Number of trials Keeping all else constant, how does the DCB perform with varying numbers of trials. Prediction: DCB performance will asymptotically converge to some maximum performance. Hopefully it works well for approximately 300 trials, since I would like to apply this algorithm to more than simulated data. bias = \\(0\\) drift = \\(0.9\\) noise = \\(4\\) bound = \\(\\pm 50\\) ## ERROR : infinite or missing values in &#39;x&#39; The DCB performs ok at 150 trials. By 360 trials, it looks like it is fitting fixed bounds decently. Not too much performance improvement from 360 to 500 trials. I think this ultimately depends on how many choices are made at every time point, which may or may not be dependent on the total number of trials. 2.1.5.2 Collapsing bounds cyborg Drift So far, our cyborgs are just linear accumulators since drift rate has been set to 1 for the cyborgs. This is a special case of the DDM, but does the DCB still work for other drift rates? Prediction: The DCB should work fine regardless of the drift rate. We just need to account for the drift rate in our accumulated evidence. This should also extend to attentional discounting from the aDDM, so long as we use fixation data. bias = \\(0\\) noise = \\(4\\) Weibull scale = \\(4\\) Weibull shape = \\(3\\) Weibull asymptote = \\(10\\) ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; At low drift rates, the DCB fails to capture the asymptote of the collapsed bounds. Otherwise, it performs fine. Noise This is important to consider since accumulated evidence can bleed over LDA boundaries. The more noise there is, the more that measurements of accumulated evidence will bleed over into other classifications. For instance, with a larger noise, there should be more “continue sampling” observations that fall above the separating plane for “choose left” and below the separating plane for “choose right”. And vice versa. bias = \\(0\\) drift = \\(0.9\\) Weibull scale = \\(4\\) Weibull shape = \\(3\\) Weibull asymptote = \\(10\\) ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; Again, performance degrades over time when noise is large. It almost looks like the boundaries collapse, then widen again. At absurdly large amounts of noise, we even see it widen, tighten, widen, and tighten (all within 10 samples!). I bet we’ll see patterns like this in real data. Weibull Shape Change the shape of the Weibull collapsing function. The larger the shape, the later the collapse. bias = \\(0\\) drift = \\(0.9\\) noise = \\(4\\) Weibull scale = \\(4\\) Weibull asymptote = \\(10\\) ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; The DCB tracks the time of collapse well. Weibull Asymptote The Weibull collapsing function starts at \\(a=100\\). It will converge to \\(0.5a+a&#39;\\). We are adjusting \\(a&#39;\\). Dropping from \\(a&#39;&gt;0\\) to \\(a&#39;=0\\) asymptotically brings us down to a bound of 50. \\(a&#39;&lt;0\\) drags the asymptote below 50. bias = \\(0\\) drift = \\(0.9\\) noise = \\(4\\) Weibull scale = \\(4\\) Weibull shape = \\(3\\) ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; The DCB tracks the asymptote of collapse well. Number of trials Keeping all else constant, how does the DCB perform with varying numbers of trials. bias = \\(0\\) drift = \\(0.9\\) noise = \\(4\\) bound = \\(\\pm 50\\) ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; Performance seems sufficient at 150 trials, and improves (with diminishing returns) at larger trial counts. 2.1.6 Conclusion Looks like DCB might work for tasks with sequential presentation and comparison of multiple stimuli, particularly in the perception and numerosity domains. Need to make sure that the variance of noise is not too large amongst subjects, otherwise DCB will likely fail to track decision boundaries. This may be partially controlled by the noisiness of stimuli. For instance, displaying streams of numbers might result in less noise than displaying streams of collections of balls (where the collections represent a number). DCB might work in as little as 150 trials per subject, though more trials only aids with accuracy. It’s performance is more dependent on drift (since we need a decent distribution across all choices at a given time) and noise (since accumulated evidence can bleed over decision boundaries). 2.2 Perceptual data, DDM We use data from a study currently in progress. I can’t share this data yet since the project is still at an early phase. Subjects simultaneously view two streams of rectangles and are asked to choose which stream has the larger average as quickly as possible (see (Tsetsos et al. 2016)). 2.2.1 Prep work Read-in and clean data Reads in data and outputs a time-series of accumulated evidence and choices (along with slider location, etc.). Choices are 0=left, 1=right, 2=continue sampling. slider.data &lt;- read.csv(&quot;data/dcb-all_dataSlider.csv&quot;) slider.data &lt;- data.frame( subject=factor(slider.data$participant), trial=slider.data$block.thisN*120 + slider.data$trial.thisN, sample=slider.data$samplePhase.thisN, choice=slider.data$choice, evidence=round((slider.data$heightR-slider.data$heightL)*100,2), sliderLoc=(slider.data$sliderLoc*2-1)*100, time=round(slider.data$sliderTime,3)*1000 ) slider.data &lt;- slider.data %&gt;% group_by(subject,trial,sample) %&gt;% summarize( choice=last(choice), evidence=last(evidence), sliderLoc=last(sliderLoc), time=last(time) ) %&gt;% ungroup() %&gt;% group_by(subject,trial) %&gt;% mutate( ae=cumsum(evidence), samples=max(sample) ) ## `summarise()` has grouped output by &#39;subject&#39;, &#39;trial&#39;. You can override ## using the `.groups` argument. slider.data$choice[slider.data$sample!=slider.data$samples] &lt;- 2 Take subj data, output figure Time dimension is along number of samples. Note that time-steps are not consistent since each pair of stimuli are displayed for a variable amount of time. plotDCB &lt;- function(data, maxSamples=10) { # Get subject&#39;s data and convert it to useable input to our DCB() function. # Requires sample, choice, ae, and trial variables in time-series panel format. subj.data &lt;- data subj.data &lt;- subj.data[,c(&#39;sample&#39;,&#39;choice&#39;,&#39;ae&#39;,&#39;trial&#39;)] # DCB subj.dcb &lt;- DCB(subj.data, maxSamples) subj.dcb tempData &lt;- subj.data tempData$choice &lt;- factor(tempData$choice, levels=c(0,1,2), labels=c(&#39;Choose left&#39;,&#39;Choose right&#39;,&#39;Continue sampling&#39;)) tempData &lt;- merge(tempData,subj.dcb[,c(&#39;sample&#39;,&#39;avgb&#39;)], by.x=&quot;sample&quot;, by.y=&quot;sample&quot;) p &lt;- tempData[tempData$sample&lt;=maxSamples,] %&gt;% ggplot(aes(x=ae, fill=choice, color=choice)) + geom_histogram(alpha=.25, bins=100, position=&#39;identity&#39;) + geom_vline(aes(xintercept=avgb), color=&#39;red&#39;, alpha=.65, size=2) + geom_vline(aes(xintercept=-avgb), color=&#39;red&#39;, alpha=.65, size=2) + coord_flip() + theme_classic() + labs(x=&#39;Accumulated Evidence&#39;, y=&#39;Sample&#39;) + xlim(c(-150,150)) + theme( plot.title = element_text(size=22), axis.ticks.x = element_blank(), axis.text.x = element_blank() ) + facet_grid(~sample, scales=&quot;free&quot;) return(p) } 2.2.2 DCB Subject 1 ## ERROR : infinite or missing values in &#39;x&#39; Not great… maybe this was just a fluke. If we consider the timepoints with the bulk of observations, then maybe we could argue evidence in favor of fixed bounds. Subject 2 ## ERROR : missing value where TRUE/FALSE needed ## ERROR : non-conformable arrays ## ERROR : non-conformable arrays ## ERROR : non-conformable arrays If we only consider points in time with a sufficient amount of data, then definitely looks like collapsing bounds. Subject 3 Not sure what to make of this. Subject 4 ## ERROR : variable 1 appears to be constant within groups ## ERROR : missing value where TRUE/FALSE needed ## ERROR : missing value where TRUE/FALSE needed If we only consider points in time with a sufficient amount of data, then looks like collapsing bounds. Conclusion For 2 out of 4 subjects, the DCB clearly provides evidence in favor of a collapsing boundary. For the remaining subjects, the DCB looks scattered. I’m beginning to question the robustness of the DCB algorithm, though it clearly does well when modeling impatient subjects! 2.3 Perceptual data, slider Instead of calculating accumulated evidence using a linear accumulator, I substitute it with slider bar location. Just curious if this works. 2.3.1 Prep work slider.data$ae &lt;- slider.data$sliderLoc 2.3.2 DCB Subject 1 ## ERROR : infinite or missing values in &#39;x&#39; More linear boundaries, but that’s because the maximum / minimum slider bar location is 0 / 100, so this approach is naturally biased towards a linear boundary. Subject 2 ## ERROR : variable 1 appears to be constant within groups ## ERROR : missing value where TRUE/FALSE needed ## ERROR : non-conformable arrays ## ERROR : non-conformable arrays ## ERROR : non-conformable arrays Subtle hints of collapsing barrier, again biased towards a linear boundary. Subject 3 Kinda looks like when noise is very large and bounds are collapsing… that trend where the boundary collapses, widens, then collapses again. Subject 4 ## ERROR : variable 1 appears to be constant within groups ## ERROR : missing value where TRUE/FALSE needed ## ERROR : missing value where TRUE/FALSE needed Subtle hints of collapsing barrier. Conclusion The fact that the “accumulated evidence” for choices cannot differ from \\(\\pm 100\\) biases the collapsing boundary towards linear bounds. There is still some hint of collapse for the subjects who previously displayed collapsing boundaries, but I’m not sure we can call this a success. That’s ok, I took a shot in the dark asking if the algorithm could work with just slider bar locations, and it turns out that it probably doesn’t. 2.4 Value-based data, DDM I use data from (Eum, Dolbier, and Rangel 2022) visible trials. The data can be downloaded here: https://www.rnl.caltech.edu/publications/index.html. I am not assuming a drift diffusion model for accumulated evidence. I am simply assuming a linear accumulator (drift=1). If the DCB exhibit a bias that is linear in samples, then perhaps performance can be improved by using subject-specific drift rate parameters. However, if the DCB exhibit non-linear bias, then I find it hard to believe that drift rate will make much difference. 2.4.1 Prep work Read data load(&quot;data/dcb-choices.R&quot;) ddm.data &lt;- data.frame( subject=choices$parcode, hidden=choices$hidden, condition=choices$lr_diff, response=choices$choice, RT=choices$rt/1000 ) ddm.data &lt;- ddm.data[ddm.data$hidden==0,] #keep visible trials Take subj data, output figure Let’s assume one sample occurs every 250 ms. This splits the time dimension into roughly the same resolution as the simulations above. plotDCB &lt;- function(data, maxSamples=10) { # Get subject&#39;s data and convert it to useable input to our DCB() function. # Requires sample, choice, ae, and trial variables in time-series panel format. subj.data &lt;- data subj.data$samples &lt;- (round(subj.data$RT/.25)*.25) /.25 #250m subj.data$trial &lt;- c(1:length(subj.data$RT)) subj.data &lt;- subj.data[rep(seq(nrow(subj.data)), subj.data$samples),] #repeat each row by number of samples subj.data &lt;- subj.data %&gt;% group_by(trial) %&gt;% mutate(ae=cumsum(condition), sample=row_number()) subj.data$choice &lt;- subj.data$response subj.data[subj.data$sample!=subj.data$samples,&#39;choice&#39;] &lt;- 2 subj.data &lt;- subj.data[,c(&#39;sample&#39;,&#39;choice&#39;,&#39;ae&#39;,&#39;trial&#39;)] # DCB subj.dcb &lt;- DCB(subj.data, maxSamples) subj.dcb tempData &lt;- subj.data tempData$choice &lt;- factor(tempData$choice, levels=c(0,1,2), labels=c(&#39;Choose right&#39;,&#39;Choose left&#39;,&#39;Continue sampling&#39;)) tempData &lt;- merge(tempData,subj.dcb[,c(&#39;sample&#39;,&#39;avgb&#39;)], by.x=&quot;sample&quot;, by.y=&quot;sample&quot;) p &lt;- tempData[tempData$sample&lt;=maxSamples,] %&gt;% ggplot(aes(x=ae, fill=choice, color=choice)) + geom_histogram(alpha=.5, bins=50, position=&#39;identity&#39;) + geom_vline(aes(xintercept=avgb), color=&#39;red&#39;, alpha=.5, size=2) + geom_vline(aes(xintercept=-avgb), color=&#39;red&#39;, alpha=.5, size=2) + coord_flip() + theme_classic() + labs(x=&#39;Accumulated Evidence&#39;, y=&#39;Sample (250 ms)&#39;) + xlim(c(-50,50)) + theme( plot.title = element_text(size=22), axis.ticks.x = element_blank(), axis.text.x = element_blank() ) + facet_grid(~sample, scales=&quot;free&quot;) return(p) } 2.4.2 DCB Subj 225 ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; Perhaps collapsing boundary with large noise? This conclusion is based on the simulations of the collapsing cyborg with a large noise parameter. Subj 304 ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; Not sure what to make of this. Subj 316 ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; Looks a lot like the collapsing barrier cyborg with large noise. Subj 319 ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; Potentially an increasingly patient subject? More likely that the algorithm is struggling to fit properly. 2.4.3 Conclusion DCB is not looking promising in the value-based choice domain. Of course, I don’t know what subjects’ actual collapsing bounds are, but my attempt at fitting the DCB either suggests there is too much noise in the process for DCB to be effective. Perhaps value signals are too noisy compared to perceptual or numerosity stimuli. Also, the rate of evidence accumulation in these cases is constant since they are staring at the same stimuli for the entirety of the decision making process. I don’t think the DCB was intended to be used on stimuli like this, so it’s like trying to use a fork to drink soup. 2.5 Value-based data, aDDM Now, let’s see what happens if we calculate accumulated evidence with the aDDM (without noise). I have a hunch that this might work better! 2.5.1 Prep work Read data We want to take the choice-fixations data and transform it into an object that we can feed into plotDCB() below. Ideally, the output should have: * subject * trial * a time dimension * accumulated evidence (at that point in time) * choice We also need subject-speccific aDDM estimates. # Choice-fixation data load(&quot;data/dcb-cf.R&quot;) ddm.data &lt;- data.frame( subject=cf$parcode, trial=cf$trial, hidden=cf$hidden, vl=cf$avgWTP_left, vr=cf$avgWTP_right, loc=cf$location, dur=cf$duration, choice=cf$choice, rt=cf$rt/1000 ) ddm.data &lt;- ddm.data[ddm.data$hidden==0,] #keep visible trials # Subject-level aDDM estimates subs &lt;- unique(ddm.data$subject) selected.subs &lt;- c(225,304,316,319) #Pick 4 subjects selected.subs.ind &lt;- c(25,28,38,41) #indexes ddm.estim &lt;- read.csv(&quot;data/dcb-MAP_estimates.csv&quot;) # Transform data ddm.data &lt;- ddm.data[which(ddm.data$subject %in% selected.subs),] ddm.data$evidence &lt;- NA for (i in c(1:length(selected.subs))) { # looking nowhere ind &lt;- (ddm.data$subject==selected.subs[i] &amp; (ddm.data$loc==0 | ddm.data$loc==4) ) ddm.data[ind,&#39;evidence&#39;] &lt;- 0 # looking right ind &lt;- (ddm.data$subject==selected.subs[i] &amp; ddm.data$loc==2) ddm.data[ind,&#39;evidence&#39;] &lt;- ddm.estim$d_v[selected.subs.ind[i]] * (ddm.estim$t_v[selected.subs.ind[i]]*ddm.data[ind,&#39;vl&#39;] - ddm.data[ind,&#39;vr&#39;]) # looking left ind &lt;- (ddm.data$subject==selected.subs[i] &amp; ddm.data$loc==1) ddm.data[ind,&#39;evidence&#39;] &lt;- ddm.estim$d_v[selected.subs.ind[i]] * (ddm.data[ind,&#39;vl&#39;] - ddm.estim$t_v[selected.subs.ind[i]]*ddm.data[ind,&#39;vr&#39;]) } ddm.data &lt;- ddm.data[rep(seq(nrow(ddm.data)), ddm.data$dur),] #repeat each row by number of samples ddm.data &lt;- ddm.data %&gt;% group_by(subject,trial) %&gt;% mutate(ae=cumsum(evidence), time=row_number()) Take subj data, output figure Let’s assume one sample occurs every 250 ms. This splits the time dimension into roughly the same resolution as the simulations above. This overwrites the previous function so that we can calculate accumulated evidence (ae) using the aDDM instead of a linear accumulator. plotDCB &lt;- function(data, maxSamples=10) { # Get subject&#39;s data and convert it to useable input to our DCB() function. # Requires sample, choice, ae, and trial variables in time-series panel format. data$time &lt;- ceiling(data$time / 250) * 250 #round up times to the nearest 250 above. subj.data &lt;- data %&gt;% group_by(subject,trial,time) %&gt;% summarize( sample=last(time)/250, choice=last(choice), ae=last(ae) ) %&gt;% ungroup() %&gt;% group_by(subject,trial) %&gt;% mutate( samples=max(sample) ) subj.data[subj.data$sample!=subj.data$samples,&#39;choice&#39;] &lt;- 2 # DCB subj.dcb &lt;- DCB(subj.data, maxSamples) subj.dcb tempData &lt;- subj.data tempData$choice &lt;- factor(tempData$choice, levels=c(0,1,2), labels=c(&#39;Choose right&#39;,&#39;Choose left&#39;,&#39;Continue sampling&#39;)) tempData &lt;- merge(tempData,subj.dcb[,c(&#39;sample&#39;,&#39;avgb&#39;)], by.x=&quot;sample&quot;, by.y=&quot;sample&quot;) p &lt;- tempData[tempData$sample&lt;=maxSamples,] %&gt;% ggplot(aes(x=ae, fill=choice, color=choice)) + geom_histogram(alpha=.5, bins=25, position=&#39;identity&#39;) + geom_vline(aes(xintercept=avgb), color=&#39;red&#39;, alpha=.5, size=2) + geom_vline(aes(xintercept=-avgb), color=&#39;red&#39;, alpha=.5, size=2) + coord_flip() + theme_classic() + labs(x=&#39;Accumulated Evidence&#39;, y=&#39;Sample (250 ms)&#39;) + xlim(c(-25,25)) + theme( plot.title = element_text(size=22), axis.ticks.x = element_blank(), axis.text.x = element_blank() ) + facet_grid(~sample, scales=&quot;free&quot;) return(p) } 2.5.2 DCB Subj 225 ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; Confusion… Subj 304 ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; Looks like collapsing bounds with large noise? Subj 316 ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; Again, looks like collapsing bounds with large noise??? Subj 319 ## ERROR : infinite or missing values in &#39;x&#39; ## ERROR : infinite or missing values in &#39;x&#39; More confusion… 2.5.3 Conclusion I’m not sure the DCB’s make any sense here, but if we were to interpret them, then subjects mostly seem like they have collapsing bounds with large noise. This might make sense if we believe that value signals are noisier than perceptual or numerosity stimuli, but that also makes DCB a poor candidate algorithm for fitting decision bounds to value-based behavioral data. 2.6 Discussion Overall, the DCB seems to show some promise with perceptual data, but not with value-based data. This is by no fault of the DCB, I was just curious if it would work in the value-based domain (like a baby trying to drink soup with a fork). For perceptual data, I think it works particularly well on subjects who are very impatient (both of the collapsing bound subjects in the perceptual data mentioned that they were getting very impatient with the task). Aside from those subjects, it seems to estimate boundaries that appear very volatile over time. I’m not really sure what to make of those results, and the extreme volatility does not leave much room for interpretation. Personally, I think that although the DCB could be estimating decision boundaries more accurately, we lose the interpretability that comes with using a functional form for collapsing bounds. At the end of the day, isn’t that the purpose of a simplified model of decision making? Furthermore, if subjects aren’t arriving at all possible choices early on in the trial, the DCB fails to estimate boundaries. This prevents us from estimating the starting point of the decision boundaries. References "],["mem-aDDM.html", "Chapter 3 mem-aDDM 3.1 Introduction 3.2 Warning 3.3 Methods 3.4 How should drift change? 3.5 mem-aDDM 3.6 aDDM 3.7 Compare predictions", " Chapter 3 mem-aDDM (TL;DR) I tried to incorporate the effects of working memory (mem-) into the Attentional Drift-Diffusion-Model (aDDM) by allowing the drift rate parameter to scale with the number of previous exposures to the chosen stimulus in the session. This was an attempt to (1) improve the accuracy of response time predictions from the aDDM and (2) model shorter response times with repeated exposures. It didn’t work, but at least now I know what not to try next ¯\\(ツ)/¯. 3.1 Introduction In value-based decisions, there are different ways that familiarity with a stimulus might affect decisions over time. Adopting intuition from Signal Detection Theory, repeated exposure to a stimulus might reduce the variance of the value signal. When it comes to sequential sampling models, we can model this in two ways. The obvious approach would be to reduce the noise parameter as a function of stimulus exposure time. However, previous studies have shown that response times decrease with repeated exposure to a stimulus in an experiment (a wonderful report written by Trinity Pruitt when she was rotating through the Rangel Lab in 2021, or (Agranov and Ortoleva 2017)). A reduced noise parameter can only serve to increase response times, therefore this adjustment to the model would likely fail to account for behavior. Similarly, I believe the extension of the DDM used in (Agranov and Ortoleva 2017) fails to account for the effects of repeated exposure on parameters of the DDM. Source: Trinity Pruitt. Faster RTs for stimuli seen more than the median number of times a stimulus is seen in (Smith and Krajbich 2018) and in (Eum, Dolbier, and Rangel 2022). Instead, I hypothesize that familiarity with a stimulus will affect the drift rate parameter. For one, a drift rate parameter that scales with previous encounters is capable of explaining faster response times with repeated exposure. (Kelly and O’Connell 2013) find that faster response times correlate with faster buildup rate of centroparietal positive potential independent of stimulus coherence, suggesting that faster response times might be explained by a larger drift rate parameter. But the main inspiration behind an encounter-scaling drift rate parameter comes from the memory and decision-making literature. (Shadlen and Shohamy 2016) argue that value signals are modulated by memory (episodic, working, etc.), specifically that value signals in sequential sampling models integrated in the LIP are modulated by activity in the hippocampus. Studies using EEG also find a neural signal that reflects sampling from memory (van Ede and Nobre 2022). If we buy the argument that sampling from memory is more difficult than sampling from a visual representation ((Weilbächer et al. 2021) and (Eum, Dolbier, and Rangel 2022)), then we might suspect that recent exposure to a stimulus will reduce the difficulty of sampling information from working memory. Again, this could potentially result in a smaller noise parameter, but seeing that this fails to explain behavior, I believe it is instead explained by drift rate parameter that scales with previous encounters. I also think this will make different RT predictions depending on the value difference. Since value differences integrate over time, the lack of evidence in a difficult decision compounds over time. This means that a larger drift rate parameter will reduce response times by more in difficult choices than in easy choices. This may remedy problems that the aDDM has with fitting RT distributions across value differences (see below). The goals of this report: Incorporate the idea that internal samples are modulated by (and sometimes even sampled from) memory into a sequential sampling model. Build a variation of the aDDM that explains shorter response times with more familiar stimuli. Improve the performance of the aDDM, which has previously overestimated response times when choices are difficult. 3.2 Warning Not a great display of coding. But with one weekend for a side-project, this is what I wound up with. If the project turns into something bigger, then I’ll consider re-writing the code into something more elegant. 3.3 Methods 3.3.1 Prep work 3.3.1.1 Load libraries rm(list = ls()) seed = 1337 library(dplyr) library(ggplot2) library(hrbrthemes) library(runjags) library(brms) #library(cmdstanr) library(data.table) library(plotrix) library(grid) library(gridExtra) #set_cmdstan_path(&quot;D:/Program Files/R-4.0.2/library/cmdstan-2.24.1&quot;) #gotta do this everytime :\\ 3.3.1.2 Read-in data and calculations I will use data from the “two food” choice task in (Smith and Krajbich 2018). The data can be downloaded here: https://osf.io/x2jhp/?view_only=2669d8f3983d4442952a52c5de5814f7. I calculate a variable called “PreviousEncountersChosen”, which counts the number of previous trials in which the subject has seen the chosen item for this trial. I was thinking about extending the model so that we calculate “PreviousExposure” up until the current fixation, but this would require that we use a different (and MUCH slower) toolbox to estimate the aDDM. If we fit the data by fixations, then we need should use the Tavares toolbox (Tavares, Perona, and Rangel 2017). But, that will take a long time and will not result in posterior distributions for parameter estimates. So instead, I will use the Lombardi and Hare toolbox (Lombardi and Hare 2021) and let drift rate vary trial-by-trial systematically as a function of previous encounters. This differs from the trial-by-trial variability in drift rate that draws drift from a distribution, as in (Lombardi and Hare 2021) or (Eum, Dolbier, and Rangel 2022). load(&quot;data/mem-aDDM-smithkrajbich2018.RData&quot;) twofoodeyedata &lt;- twofoodeyedata %&gt;% group_by(SubjectNumber, Trial) %&gt;% mutate( # fixation number fixNum=row_number() ) # Running counts of the number of times the subjects have seen the left and right options across previous trials twofoodchoicedata$PreviousEncounterLeft &lt;- NA twofoodchoicedata$PreviousEncounterRight &lt;- NA data &lt;- twofoodchoicedata[order(twofoodchoicedata$SubjectNumber, twofoodchoicedata$Trial),] for (n in 1:length(data$SubjectNumber)) { tempdata &lt;- data[data$SubjectNumber==data$SubjectNumber[n] &amp; data$Trial&lt;=data$Trial[n],] prevList &lt;- rbind(tempdata$FoodLeft,tempdata$FoodRight) data$PreviousEncounterLeft[n] &lt;- sum(prevList==data$FoodLeft[n])-1 data$PreviousEncounterRight[n] &lt;- sum(prevList==data$FoodRight[n])-1 } twofoodchoicedata &lt;- data twofoodchoicedata$PreviousEncounterBoth &lt;- twofoodchoicedata$PreviousEncounterLeft+twofoodchoicedata$PreviousEncounterRight twofoodchoicedata$PreviousEncounterChosen &lt;- ifelse(twofoodchoicedata$LeftRight==1, twofoodchoicedata$PreviousEncounterLeft, twofoodchoicedata$PreviousEncounterRight) food &lt;- merge(twofoodchoicedata, twofoodeyedata, by=c(&quot;SubjectNumber&quot;, &quot;Trial&quot;)) food &lt;- food[order(food$SubjectNumber, food$Trial, food$fixNum),] food$valDiff &lt;- food$ValueLeft-food$ValueRight food$difficulty &lt;- abs(food$ValueLeft-food$ValueRight) food$fixID &lt;- ifelse(food$ROI==1, food$FoodLeft, food$FoodRight) # ID for currently fixated food food$choiceID &lt;- ifelse(food$LeftRight==1, food$FoodLeft, food$FoodRight) # ID for chosen food food &lt;- food %&gt;% group_by(SubjectNumber, fixID) %&gt;% mutate( # Get total dwell time up until this fixation Exposure = cumsum(DwellLength)-DwellLength ) %&gt;% ungroup() %&gt;% group_by(SubjectNumber, Trial, fixID) %&gt;% mutate( # Get total dwell time up until this trial for each unique stimulus TrialPreviousExposure = min(Exposure) ) %&gt;% ungroup() %&gt;% group_by(SubjectNumber, Trial) %&gt;% mutate( # Get total dwell time for both stimuli up until this trial PreviousExposureBoth = sum(unique(TrialPreviousExposure),na.rm=TRUE) ) %&gt;% ungroup() %&gt;% mutate( fixToChoice = (fixID==choiceID), placeholder = 0 ) food$placeholder &lt;- ifelse(food$fixToChoice==1, food$TrialPreviousExposure, 0) food &lt;- food %&gt;% group_by(SubjectNumber, Trial) %&gt;% mutate( PreviousExposureChosen = max(placeholder), # Get total dwell time for chosen stimulus up until this trial maxFixNum = max(fixNum) # use this to get middle fixation indicators later ) # middle fixations food$middleFix &lt;- (food$fixNum&gt;1 &amp; food$fixNum!=food$maxFixNum) 3.4 How should drift change? Let’s regress response time on value difference (L-R) and various metrics of previous exposure. If previous exposure leads to larger drift rate parameters, then we necessarily need a negative correlation between response time and previous exposure. Really quickly, let’s define the data set we will use for regressions. This should be trial-by-trial data. Also, let’s change RT to ms for better parameterization. Also, let’s set the settings for the hierarchical regressions. data &lt;- food[food$fixNum==1,] data$RT &lt;- data$RT*1000 # convert to ms chainscores = 3 iterations = 6000 burnin = floor(iterations/2) 3.4.1 Previous exposure to both options Here, I take previous exposure as the sum of total fixation time to either option in previous trials. #reg.exp.both &lt;- brm( # RT ~ difficulty+PreviousExposureBoth + (1+difficulty+PreviousExposureBoth|SubjectNumber), # data=data, # family=gaussian, # chains=chainscores, # cores=chainscores, # iter=iterations, # warmup=burnin, # seed=seed, # refresh=0 #) reg.exp.both = lm(RT ~ difficulty+PreviousExposureBoth + (1+difficulty+PreviousExposureBoth|SubjectNumber), data=data) reg.exp.both ## ## Call: ## lm(formula = RT ~ difficulty + PreviousExposureBoth + (1 + difficulty + ## PreviousExposureBoth | SubjectNumber), data = data) ## ## Coefficients: ## (Intercept) ## 1521.98 ## difficulty ## -66.48 ## PreviousExposureBoth ## 109.17 ## 1 + difficulty + PreviousExposureBoth | SubjectNumberTRUE ## NA The results don’t look very promising. It doesn’t seem like previous exposure to both options is affecting the response times. 3.4.2 Previous exposure to chosen option Here, I take previous exposure as the total fixation time to the chosen option in previous trials. #reg.exp.chosen &lt;- brm( # RT ~ difficulty+PreviousExposureChosen + (1+difficulty+PreviousExposureChosen|SubjectNumber), # data=data, # family=gaussian, # chains=chainscores, # cores=chainscores, # iter=iterations, # warmup=burnin, # seed=seed, # refresh=0 #) reg.exp.chosen = lm(RT ~ difficulty+PreviousExposureChosen + (1+difficulty+PreviousExposureChosen|SubjectNumber), data=data) reg.exp.chosen ## ## Call: ## lm(formula = RT ~ difficulty + PreviousExposureChosen + (1 + ## difficulty + PreviousExposureChosen | SubjectNumber), data = data) ## ## Coefficients: ## (Intercept) ## 1571.36 ## difficulty ## -67.62 ## PreviousExposureChosen ## 159.42 ## 1 + difficulty + PreviousExposureChosen | SubjectNumberTRUE ## NA The results don’t look very promising. It doesn’t seem like previous exposure to the chosen option is affecting the response times. 3.4.3 Previous encounters with both options Here, I take previous encounters as the number of times the subject has encountered both options before. #reg.enc.both &lt;- brm( # RT ~ difficulty+PreviousEncounterBoth + (1+difficulty+PreviousEncounterBoth|SubjectNumber), # data=data, # family=gaussian, # chains=chainscores, # cores=chainscores, # iter=iterations, # warmup=burnin, # seed=seed, # save_pars = save_pars(all = TRUE), #for LOO CV later # refresh=0 #) reg.enc.both = lm(RT ~ difficulty+PreviousEncounterBoth + (1+difficulty+PreviousEncounterBoth|SubjectNumber), data=data) reg.enc.both ## ## Call: ## lm(formula = RT ~ difficulty + PreviousEncounterBoth + (1 + difficulty + ## PreviousEncounterBoth | SubjectNumber), data = data) ## ## Coefficients: ## (Intercept) ## 1893.35 ## difficulty ## -71.17 ## PreviousEncounterBoth ## -41.61 ## 1 + difficulty + PreviousEncounterBoth | SubjectNumberTRUE ## NA Interestingly, previous encounters with both options is negatively correlated with response times. 3.4.4 Previous encounters with chosen option Here, I take previous encounters as the number of times the subject has encountered the chosen option before. #reg.enc.chosen &lt;- brm( # RT ~ difficulty+PreviousEncounterChosen + (1+difficulty+PreviousEncounterChosen|SubjectNumber), # data=data, # family=gaussian, # chains=chainscores, # cores=chainscores, # iter=iterations, # warmup=burnin, # seed=seed, # save_pars = save_pars(all = TRUE), #for LOO CV later # refresh=0 #) reg.enc.chosen = lm(RT ~ difficulty+PreviousEncounterChosen + (1+difficulty+PreviousEncounterChosen|SubjectNumber), data=data) reg.enc.chosen ## ## Call: ## lm(formula = RT ~ difficulty + PreviousEncounterChosen + (1 + ## difficulty + PreviousEncounterChosen | SubjectNumber), data = data) ## ## Coefficients: ## (Intercept) ## 1836.70 ## difficulty ## -70.50 ## PreviousEncounterChosen ## -53.42 ## 1 + difficulty + PreviousEncounterChosen | SubjectNumberTRUE ## NA It seems that previous encounters with the chosen option is also negatively correlated with response times. 3.4.5 Model comparison So now we have two potential ways in which working memory might affect response times. (1) Previous encounters with both options, and (2) Previous encounters with the chosen item. Let’s run a quick model comparison using Leave-One-Out Cross Validation to see which explains the data better. We are comparing the expected log pointwise predictive density (ELPD) of the “chosen” model compared to the “both” model. For this, we should look at the elpd_loo. The better model has the higher elpd_loo. #loo1 &lt;- loo(reg.enc.both) #loo2 &lt;- loo(reg.enc.chosen) #comparison &lt;- loo_compare(loo1,loo2) #print(comparison, simplify=FALSE, digits=3) [I ran these at some point in the past, but I didn’t want to have to rerun the MCMC algorithms when I reknit the book again. I’ve commented out all the analyses using Bayesian heirarchical modeling and used OLS instead. This means there’s no need to use ELPD, but I’ve left the written analyses in from a long time ago so you can see what the results were.] It looks like previous encounters with the chosen option slightly outperforms previous encounters with both options. The results here suggest that previous encounters with the chosen option are correlated with faster responses. My hunch is that working memory is somehow affecting behavior. My hypothesis is that repeated exposure to the chosen item is increasing the ease with which subjects can sample value signals from working memory (Weilbächer et al. 2021). These results make sense with the previous literature. (Weilbächer et al. 2021) showed that the amount of attention to an item did not affect whether or not subjects remembered that item. However, (Agranov and Ortoleva 2017) found that repeated encounters with the same item sped up response times. Perhaps value become easier to sample from memory with more encounters, but is not modulated by the amount of exposure per encounter. In the next section, I will design a variation of the aDDM where the drift rate scales with previous encounters with the chosen item. 3.5 mem-aDDM 3.5.1 Fitting Methods The general piecewise constant DDM (pcDDM) does not have fully time-dependent drift rates. Instead, it has drift rates that are constant over discrete intervals. The continuous pcDDM is written as follows: \\(dx(t) = \\mu(t) dt + \\sigma dW(t)\\) where: \\(x(t)\\) is evidence at time \\(t\\) \\(\\mu(t)\\) is the drift rate at time \\(t\\) \\(\\sigma\\) is the standard deviation of the Brownian motion \\(W(t)\\) is standard Brownian motion Bias is \\(x(0)=x_0\\). Drift is \\(\\mu(t)=\\mu_i\\) for \\(t_i \\leq t &lt; t_{i+1}\\). Response time is \\(\\tau = \\inf\\{t&gt;0|x(t)\\not\\in(-B,B)\\}\\). Following (Lombardi and Hare 2021), we can rewrite drift rate when two conditions hold: (1) when it is constant in discrete time intervals, and (2) when stopping time is explicitly known. We rewrite it: \\[\\begin{equation} \\begin{aligned} \\mu(t) &amp;= \\sum_{i=0}^{n-1} \\mu_i 1_{[t_i,t_{i+1})} \\\\ \\int_0^\\tau \\mu(t) dt &amp;= \\int_0^\\tau \\sum_{i=0}^{n-1} \\mu_i 1_{[t_i,t_{i+1})} dt \\\\ \\int_0^\\tau \\sum_{i=0}^{n-1} |\\mu_i 1_{[t_i,t_{i+1})}| dt &amp;&lt; \\infty, \\; \\therefore \\text{by Fubini&#39;s theorem,} \\\\ \\int_0^\\tau \\mu(t) dt &amp;= \\sum_{i=0}^{n-1} \\int_0^\\tau \\mu_i 1_{[t_i,t_{i+1})} dt \\\\ &amp;= \\sum_{i=0}^{n-1} \\int_{t_i}^{t_{i+1}} \\mu_i dt \\\\ &amp;= \\tau \\left( \\sum_{i=0}^{n-1} \\int_{t_i}^{t_{i+1}} \\mu_i dt \\right) \\frac{1}{\\tau} \\\\ \\text{By Fundamental theorem of} &amp;\\text{ calculus and some continuity conditions...} \\\\ &amp;= \\int_0^\\tau \\frac{d}{d\\tau} \\left[ \\tau \\left( \\sum_{i=0}^{n-1} \\int_{t_i}^{t_{i+1}} \\mu_i dt \\right) \\frac{1}{\\tau} \\right] dt \\\\ &amp;= \\int_0^\\tau \\left( \\frac{1}{\\tau} \\sum_{i=0}^{n-1} \\int_{t_i}^{t_{i+1}} \\mu_i dt \\right) dt - \\int_0^\\tau \\left( \\frac{1}{\\tau} \\sum_{i=0}^{n-1} \\int_{t_i}^{t_{i+1}} \\mu_i dt \\right) dt \\\\ &amp;= ??? \\\\ &amp;= \\int_0^\\tau \\left( \\frac{1}{\\tau} \\sum_{i=0}^{n-1} \\int_{t_i}^{t_{i+1}} \\mu_i dt \\right) dt \\\\ \\text{Let } t_0=0 \\text{ and } t_n=\\tau. &amp;\\text{ If } n \\text{ is the number of intervals, then} \\\\ \\mu(t) &amp;= \\frac{1}{\\tau} \\sum_{i=0}^{n-1} \\int_{t_i}^{t_{i+1}} \\mu_i dt \\\\ &amp;= \\frac{1}{\\tau} \\sum_{i=0}^{n-1} \\mu_i (t_{i+1}-t_i) \\end{aligned} \\end{equation}\\] Here, \\(\\mu_i\\) is constant across each time interval \\((t_{i+1}-t_i)\\). The drift rate in the aDDM can be written as: \\(\\bar{\\mu} = \\frac{\\tau_A}{\\tau} d (V_A-\\theta V_B) + \\frac{\\tau_B}{\\tau} d (\\theta V_A- V_B)\\) I modify drift rate to account for previous encounters with the chosen option. Note that this remains constant across an entire trial, thus we can transform the drift rate parameter and still use the toolbox by (Lombardi and Hare 2021): \\(\\bar{\\mu} = (d+\\gamma \\text{PreviousEncounters}) \\left[ \\frac{\\tau_A}{\\tau} (V_A-\\theta V_B) + \\frac{\\tau_B}{\\tau} (\\theta V_A- V_B) \\right]\\) where \\(\\text{PreviousEncounters}\\) is the number of times the chosen item was seen in previous trials. 3.5.2 Lombardi &amp; Hare Toolbox This is the part of the toolbox that prepares the data. I’ve modified it to include PreviousEncounters. # # # Input a dataframe with: # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # choice -&gt; =1 if left food item chosen, =0 if right food item chosen # leftval -&gt; value option on the left # rightval -&gt; value option on the right # rt -&gt; reaction time in ms # fixnum -&gt; fixation number # fixdur -&gt; fixation duration in ms # pe -&gt; total number of times the chosen option was seen in previous trials # roi -&gt; region of interest of the fixation (1 if fixation to the left option, 2 to the right option) # trial -&gt; trial number # subject -&gt; subject number # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # LHToolbox &lt;- function(data) { # subject numbers subjs&lt;- unique(data$subject) # calculate total fixation duration # total fixation time to the left option # and total fixation time to the right option for( s in subjs){ for (t in unique(data$trial[data$subject==s])){ #index for all fixations in one trial ind=which(data$subject==s &amp; data$trial==t) #index for left fixations in the trial indl=which(data$subject==s &amp; data$trial==t &amp; data$roi==1) #index for right fixations in the trial indr=which(data$subject==s &amp; data$trial==t &amp; data$roi==0) #total fixation duration data$totfix[data$subject==s &amp; data$trial==t] = sum(data$fixdur[ind]) #fixation time to the left option data$fixleft[data$subject==s &amp; data$trial==t] = sum(data$fixdur[indl]) #fixation time to the right option data$fixright[data$subject==s &amp; data$trial==t] = sum(data$fixdur[indr]) } } # discard all the fixations, keep the first one data&lt;-data[data$fixnum==1,] #non decision time = rt - total fixation time data$ndt &lt;- (data$rt - data$totfix) # in seconds data$ndt[data$ndt&lt;0] &lt;- 0.0001 # you can decide whether to fit the ndt or give it as input to the model # NB BEFORE FITTING THE MODEL MAKE SURE YOU HAVE NO NAN or NA IN YOUR DATA #--------------------------------#-------------------------------- # RT is positive if left food item choosen, negative if right food item chosen data$rtPN[data$choice==1]&lt;- data$rt[data$choice==1] # in seconds data$rtPN[data$choice==0]&lt;- -data$rt[data$choice==0] # in seconds # Index of subjects idxP = as.numeric(ordered(data$subject)) #makes a sequentially numbered subj index # rescale the value of the options v_left = data$leftval/10 # Smith &amp; Krajbich 2018 scale was from 1-10 v_right = data$rightval/10 # value diff vDiff = round(v_left-v_right,1) # proportion of fixations to the left option (nb. fixright = 1-gazeL) gazeL = data$fixleft/data$totfix # rt to fit y = data$rtPN # number of trials N = length(y) # number of subjects ns = length(unique(idxP)) # non-decision time ndt = data$ndt # previous encounters, scaled from 0 to 1 by the maximum number of previous encounters. pe = data$pe/max(data$pe) #-------------------------------------------- # fit the model # data dat &lt;- list( subject=data$subject, trial=data$trial, choice=data$choice, rt=data$rt, N=N, y=y, idxP=idxP, v_L=v_left, v_R=v_right, vDiff=vDiff, gazeL=gazeL, ns=ns, ndt=ndt, pe=pe ) return(dat) } 3.5.3 JAGS code \\(RDV_t = RDV_{t-1} + (d+\\gamma*\\text{PreviousEncounters})\\mu+\\epsilon\\) where \\(\\mu=(V_L-\\theta V_R)\\) if looking left, and \\(\\mu=(\\theta V_L-V_R)\\) if looking right. \\(\\epsilon \\sim N(0,\\sigma)\\) is white, Gaussian noise. \\(\\gamma\\) is sensitivity to previous time spent looking at either stimuli. Don’t forget that JAGS rnorm works with precision… so confusing keeping track of what Stan or JAGS use… cat( &quot;model { # drift rate d_mu ~ dunif(0.00001,50) d_pr ~ dgamma(1, 0.1) # previous exposure sensitivity g_mu ~ dunif(0.00001,50) g_pr ~ dgamma(1, 0.1) # noise sig_mu ~ dunif(0.000001, 2) sig_pr ~ dgamma(1, 0.1) # Bias of the DDM bias_alpha &lt;- bias_mu * bias_kappa bias_beta &lt;- (1 - bias_mu) * bias_kappa bias_mu ~ dbeta(2, 2)T(0.01,0.99) bias_kappa ~ dgamma(1, 0.5) # attentional bias theta_mu ~ dnorm(.5,.3)T(0,1) theta_pr ~ dgamma(1, 0.1) for (p in 1:ns) { # subject level d[p] ~ dnorm(d_mu, d_pr)T(0.000001,50) g[p] ~ dnorm(g_mu, g_pr)T(0.000001,50) sig[p] ~ dnorm(sig_mu, sig_pr)T(0.00001,2) bias[p] ~ dbeta(bias_alpha, bias_beta)T(0.01,0.99) theta[p] ~ dnorm(theta_mu, theta_pr)T(0,1) } for (i in 1:N) { # trial level ## WIENER model, fixing the threshold to 2 and estimating the noise y[i] ~ dwieners(2, tau[i], bet[i], w[i], sig[idxP[i]] ) # actual DDM distribution # generate trial-by-trial nDT tau[i] &lt;- ndt[i] # generate trial-by-trial Bias bet[i] &lt;- bias[idxP[i]] # Drift rate w[i] &lt;- (d[idxP[i]]+g[idxP[i]]*pe[i]) * ( (gazeL[i]*v_L[i] - (1-gazeL[i])*v_R[i]) + theta[idxP[i]]*((1-gazeL[i])*v_L[i] - gazeL[i]*v_R[i])) } }&quot;, file=&quot;temp/mem-aDDM_memaDDM.txt&quot;) 3.5.4 Fit mem-aDDM Use odd trials as training data. At the end, check whether all distributions have converged with Gelman-Rubin statistics. One key thing I’ve learned about the Lombardi-Hare Toolbox from this project: If non-decision time takes up more than 99% of the response time, the JAGS wiener module will completely break (“Node inconsistent with parent”). To use the toolbox, you need to drop the trials where (NDT/RT) &gt; 0.99! # rename and transform toolboxdata &lt;- data.frame( choice = ifelse(food$LeftRight==1,1,0), leftval = food$ValueLeft, rightval = food$ValueRight, rt = food$RT, fixnum = food$fixNum, fixdur = food$DwellLength, pe = food$PreviousEncounterChosen, roi = ifelse(food$ROI==1,1,0), trial = food$Trial, subject = food$SubjectNumber, totfix = NA, #placeholder fixleft = NA, #placeholder fixright = NA #placeholder ) train &lt;- toolboxdata[toolboxdata$trial%%2!=0,] # Training data test &lt;- toolboxdata[toolboxdata$trial%%2==0,] # Testing data # Lombardi Hare toolbox transformation train &lt;- data.frame(LHToolbox(train)) test &lt;- data.frame(LHToolbox(test)) # Drop any trials where NDT is more than 99% of the trial. Why? # (1) This breaks JAGS wiener module. # (2) Who the heck is spending more than 99% of a trial not fixating on anything? train$who &lt;- train$ndt/train$rt train &lt;- train[train$who&lt;.99,] test$who &lt;- test$ndt/test$rt test &lt;- test[test$who&lt;.99,] # Any recent adjustments to the data require that I remake the data dump that goes into JAGS dat &lt;- dump.format(list( N=length(train$y), y=train$y, idxP=as.numeric(ordered(train$subject)), v_L=train$v_L, v_R=train$v_R, gazeL=train$gazeL, ns=length(unique(train$subject)), ndt=train$ndt, pe=train$pe )) # initial guesses inits1 &lt;- dump.format(list( d_mu=0.2, d_pr=0.05, g_mu=0.2, g_pr=0.05, sig_mu=1,sig_pr=1, bias_mu=0.5, bias_kappa=1, theta_mu=0.6,theta_pr=0.5, .RNG.name=&quot;base::Super-Duper&quot;, .RNG.seed=1 )) inits2 &lt;- dump.format(list( d_mu=0.1, d_pr=0.05, g_mu=0.1, g_pr=0.05, sig_mu=1,sig_pr=1, bias_mu=0.6, bias_kappa=1, theta_mu=0.5,theta_pr=0.5, .RNG.name=&quot;base::Wichmann-Hill&quot;, .RNG.seed=2 )) inits3 &lt;- dump.format(list( d_mu=0.05, d_pr=0.05, g_mu=0.05, g_pr=0.05, sig_mu=1,sig_pr=1, bias_mu=0.4, bias_kappa=1, theta_mu=0.2,theta_pr=0.5, .RNG.name=&quot;base::Mersenne-Twister&quot;, .RNG.seed=3 )) # parameters to monitor monitor = c( &quot;d_mu&quot;, &quot;d_pr&quot;, &quot;d&quot;, # drift rate &quot;g_mu&quot;, &quot;g_pr&quot;, &quot;g&quot;, # exposure modulates drift rate &quot;sig_mu&quot;, &quot;sig_pr&quot;, &quot;sig&quot;, # noise &quot;bias_mu&quot;, &quot;bias_kappa&quot;, &quot;bias&quot;, # bias &quot;theta_mu&quot;, &quot;theta_pr&quot;, &quot;theta&quot; # attentional discounting ) # # run the fitting # set.seed(seed) # results &lt;- run.jags( # model=&quot;temp/mem-aDDM_memaDDM.txt&quot;, # monitor=monitor, # data=dat, # n.chains=3, # inits=list(inits1,inits2,inits3), # plots = TRUE, # method=&quot;parallel&quot;, # module=&quot;wiener&quot;, # burnin=15000, sample=5000 #burnin=25000 sample=10000 # ) # # memFit &lt;- add.summary(results) # # save(memFit, file=&quot;temp/mem-aDDM_memaDDMfit.RData&quot;) # # # Convergence reached? # memFit$psrf$mpsrf Looks like we’re in the clear. 3.5.5 MAP estimates Let’s get the mode and 95% HDI for each subject’s parameter estimates. # estimate and return the mode of a distribution (in this case, the posterior) estimate_mode &lt;- function(x) { d &lt;- density(x) return( d$x[which.max(d$y)] ) } # estimate 95 HDI estimate_hdi &lt;- function(x, conf=.95) { lb &lt;- 0 + (1-conf)/2 ub &lt;- 1 - (1-conf)/2 d &lt;- quantile(x, probs = c(lb,ub), na.rm = F, names = TRUE) return(d) } load(file=&quot;temp/mem-aDDM_memaDDMfit.RData&quot;) # Get the traces memtraces &lt;- data.frame(combine.mcmc(mcmc.objects=memFit$mcmc)) # placeholders memMAP &lt;- data.frame( d = unique(food$SubjectNumber), d_lb = unique(food$SubjectNumber), d_ub = unique(food$SubjectNumber), g = unique(food$SubjectNumber), g_lb = unique(food$SubjectNumber), g_ub = unique(food$SubjectNumber), sig = unique(food$SubjectNumber), sig_lb = unique(food$SubjectNumber), sig_ub = unique(food$SubjectNumber), bias = unique(food$SubjectNumber), bias_lb = unique(food$SubjectNumber), bias_ub = unique(food$SubjectNumber), theta = unique(food$SubjectNumber), theta_lb = unique(food$SubjectNumber), theta_ub = unique(food$SubjectNumber) ) for (j in unique(food$SubjectNumber)) { # column names d.ind &lt;- paste0(&#39;d.&#39;,toString(j),&#39;.&#39;) g.ind &lt;- paste0(&#39;g.&#39;,toString(j),&#39;.&#39;) sig.ind &lt;- paste0(&#39;sig.&#39;,toString(j),&#39;.&#39;) bias.ind &lt;- paste0(&#39;bias.&#39;,toString(j),&#39;.&#39;) theta.ind &lt;- paste0(&#39;theta.&#39;,toString(j),&#39;.&#39;) # Get modes memMAP$d[j] &lt;- estimate_mode(memtraces[,d.ind]) memMAP$g[j] &lt;- estimate_mode(memtraces[,g.ind]) memMAP$sig[j] &lt;- estimate_mode(memtraces[,sig.ind]) memMAP$bias[j] &lt;- estimate_mode(memtraces[,bias.ind]) memMAP$theta[j] &lt;- estimate_mode(memtraces[,theta.ind]) # Get HDIs d_hdi &lt;- estimate_hdi(memtraces[,d.ind]) g_hdi &lt;- estimate_hdi(memtraces[,g.ind]) sig_hdi &lt;- estimate_hdi(memtraces[,sig.ind]) bias_hdi &lt;- estimate_hdi(memtraces[,bias.ind]) theta_hdi &lt;- estimate_hdi(memtraces[,theta.ind]) memMAP$d_lb[j] &lt;- d_hdi[1] memMAP$g_lb[j] &lt;- g_hdi[1] memMAP$sig_lb[j] &lt;- sig_hdi[1] memMAP$bias_lb[j] &lt;- bias_hdi[1] memMAP$theta_lb[j] &lt;- theta_hdi[1] memMAP$d_ub[j] &lt;- d_hdi[2] memMAP$g_ub[j] &lt;- g_hdi[2] memMAP$sig_ub[j] &lt;- sig_hdi[2] memMAP$bias_ub[j] &lt;- bias_hdi[2] memMAP$theta_ub[j] &lt;- theta_hdi[2] } 3.6 aDDM We need something to compare the mem-aDDM to. The obvious benchmark is the aDDM since the mem-aDDM is an attempt to improve the RT fits of the aDDM. 3.6.1 JAGS code \\(RDV_t = RDV_{t-1} + d\\mu+\\epsilon\\) where \\(\\mu=(V_L-\\theta V_R)\\) if looking left, and \\(\\mu=(\\theta V_L-V_R)\\) if looking right. \\(\\epsilon \\sim N(0,\\sigma)\\) is white, Gaussian noise. \\(\\gamma\\) is sensitivity to previous time spent looking at either stimuli. Don’t forget that JAGS rnorm works with precision… so confusing keeping track of what Stan or JAGS use… cat( &quot;model { # drift rate d_mu ~ dunif(0.00001,50) d_pr ~ dgamma(1, 0.1) # noise sig_mu ~ dunif(0.000001, 2) sig_pr ~ dgamma(1, 0.1) # Bias of the DDM bias_alpha &lt;- bias_mu * bias_kappa bias_beta &lt;- (1 - bias_mu) * bias_kappa bias_mu ~ dbeta(2, 2)T(0.01,0.99) bias_kappa ~ dgamma(1, 0.5) # attentional bias theta_mu ~ dnorm(.5,.3)T(0,1) theta_pr ~ dgamma(1, 0.1) for (p in 1:ns) { # subject level d[p] ~ dnorm(d_mu, d_pr)T(0.000001,50) sig[p] ~ dnorm(sig_mu, sig_pr)T(0.00001,2) bias[p] ~ dbeta(bias_alpha, bias_beta)T(0.01,0.99) theta[p] ~ dnorm(theta_mu, theta_pr)T(0,1) } for (i in 1:N) { # trial level ## WIENER model, fixing the threshold to 2 and estimating the noise y[i] ~ dwieners(2, tau[i], bet[i], w[i], sig[idxP[i]] ) # actual DDM distribution # generate trial-by-trial nDT tau[i] &lt;- ndt[i] # generate trial-by-trial Bias bet[i] &lt;- bias[idxP[i]] # Drift rate w[i] &lt;- d[idxP[i]] * ( (gazeL[i]*v_L[i] - (1-gazeL[i])*v_R[i]) + theta[idxP[i]]*((1-gazeL[i])*v_L[i] - gazeL[i]*v_R[i])) } }&quot;, file=&quot;temp/mem-aDDM_aDDM.txt&quot;) 3.6.2 Fit aDDM Use odd trials as training data. At the end, check whether all distributions have converged with Gelman-Rubin statistics. # initial guesses inits1 &lt;- dump.format(list( d_mu=0.2, d_pr=0.05, sig_mu=1,sig_pr=1, bias_mu=0.5, bias_kappa=1, theta_mu=0.6,theta_pr=0.5, .RNG.name=&quot;base::Super-Duper&quot;, .RNG.seed=1 )) inits2 &lt;- dump.format(list( d_mu=0.1, d_pr=0.05, sig_mu=1,sig_pr=1, bias_mu=0.6, bias_kappa=1, theta_mu=0.5,theta_pr=0.5, .RNG.name=&quot;base::Wichmann-Hill&quot;, .RNG.seed=2 )) inits3 &lt;- dump.format(list( d_mu=0.05, d_pr=0.05, sig_mu=1,sig_pr=1, bias_mu=0.4, bias_kappa=1, theta_mu=0.2,theta_pr=0.5, .RNG.name=&quot;base::Mersenne-Twister&quot;, .RNG.seed=3 )) # parameters to monitor monitor = c( &quot;d_mu&quot;, &quot;d_pr&quot;, &quot;d&quot;, # drift rate &quot;sig_mu&quot;, &quot;sig_pr&quot;, &quot;sig&quot;, # noise &quot;bias_mu&quot;, &quot;bias_kappa&quot;, &quot;bias&quot;, # bias &quot;theta_mu&quot;, &quot;theta_pr&quot;, &quot;theta&quot; # attentional discounting ) # run the fitting set.seed(seed) results &lt;- run.jags( model=&quot;temp/mem-aDDM_aDDM.txt&quot;, monitor=monitor, data=dat, n.chains=3, inits=list(inits1,inits2,inits3), plots = TRUE, method=&quot;parallel&quot;, module=&quot;wiener&quot;, burnin=15000, sample=5000 ) aFit &lt;- add.summary(results) save(aFit, file=&quot;temp/mem-aDDM_aDDMfit.RData&quot;) # Convergence reached? aFit$psrf$mpsrf Looks like we’re in the clear. 3.6.3 MAP estimates Let’s get the mode and 95% HDI for each subject’s parameter estimates. load(file=&quot;temp/mem-aDDM_aDDMfit.RData&quot;) # Get the traces atraces &lt;- data.frame(combine.mcmc(mcmc.objects=aFit$mcmc)) # placeholders aMAP &lt;- data.frame( d = unique(food$SubjectNumber), d_lb = unique(food$SubjectNumber), d_ub = unique(food$SubjectNumber), sig = unique(food$SubjectNumber), sig_lb = unique(food$SubjectNumber), sig_ub = unique(food$SubjectNumber), bias = unique(food$SubjectNumber), bias_lb = unique(food$SubjectNumber), bias_ub = unique(food$SubjectNumber), theta = unique(food$SubjectNumber), theta_lb = unique(food$SubjectNumber), theta_ub = unique(food$SubjectNumber) ) for (j in unique(food$SubjectNumber)) { # column names d.ind &lt;- paste0(&#39;d.&#39;,toString(j),&#39;.&#39;) sig.ind &lt;- paste0(&#39;sig.&#39;,toString(j),&#39;.&#39;) bias.ind &lt;- paste0(&#39;bias.&#39;,toString(j),&#39;.&#39;) theta.ind &lt;- paste0(&#39;theta.&#39;,toString(j),&#39;.&#39;) # Get modes aMAP$d[j] &lt;- estimate_mode(atraces[,d.ind]) aMAP$sig[j] &lt;- estimate_mode(atraces[,sig.ind]) aMAP$bias[j] &lt;- estimate_mode(atraces[,bias.ind]) aMAP$theta[j] &lt;- estimate_mode(atraces[,theta.ind]) # Get HDIs d_hdi &lt;- estimate_hdi(atraces[,d.ind]) sig_hdi &lt;- estimate_hdi(atraces[,sig.ind]) bias_hdi &lt;- estimate_hdi(atraces[,bias.ind]) theta_hdi &lt;- estimate_hdi(atraces[,theta.ind]) aMAP$d_lb[j] &lt;- d_hdi[1] aMAP$sig_lb[j] &lt;- sig_hdi[1] aMAP$bias_lb[j] &lt;- bias_hdi[1] aMAP$theta_lb[j] &lt;- theta_hdi[1] aMAP$d_ub[j] &lt;- d_hdi[2] aMAP$sig_ub[j] &lt;- sig_hdi[2] aMAP$bias_ub[j] &lt;- bias_hdi[2] aMAP$theta_ub[j] &lt;- theta_hdi[2] } 3.7 Compare predictions 3.7.1 mem-aDDM trial simulation Write a function that simulates behavior (choice, rt) for a single trial using the mem-aDDM. It will take as inputs parameters to the mem-aDDM and fixation properties (e.g. probability of first fixating left which is a scalar, or middle fixations which is the distribution of all middle fixations for that subject from the testing set). This is code taken from (Eum, Dolbier, and Rangel 2022), which is code based on (Lombardi and Hare 2021). Note that the mem-aDDM nests the original aDDM. If you want to run an aDDM trial, all you need to do is feed in g=c(0). This eliminates any effect of previous encounter in the algorithm! mem.sim.trial &lt;- function(b, d, g, t, s, vL, vR, pe, prFirstLeft, firstFix, middleFix, latency, transition) { ################################################################### # create a variable to track when to stop (for efficiency purposes) stopper &lt;- 0 ############################## # initialize rdv at bias point RDV &lt;- b rt &lt;- 0 ############################## # latency to first fixation latencyDur &lt;- sample(latency,1) latency_err &lt;- rnorm(n=latencyDur, mean=0, sd=s) if (abs(RDV+sum(latency_err))&gt;=1) { for (t in 1:latencyDur) { RDV &lt;- RDV + latency_err[t] rt &lt;- rt + 1 lastLoc &lt;- 4 if (abs(RDV)&gt;=1) {stopper&lt;-1; break} } } else { RDV &lt;- RDV + sum(latency_err) rt &lt;- rt + latencyDur } ############################## # first fixation if (stopper==0) { firstDur &lt;- sample(firstFix,1) loc &lt;- rbinom(1,1,prFirstLeft) if (loc==1) {drift_mean &lt;- (d+g*pe)*(vL-t*vR)} if (loc==0) {drift_mean &lt;- (d+g*pe)*(t*vL-vR)} drift &lt;- drift_mean + rnorm(n=firstDur, mean=0, sd=s) if (abs(RDV+sum(drift))&gt;=1) { for (t in 1:firstDur) { RDV &lt;- RDV + drift[t] rt &lt;- rt + 1 lastLoc &lt;- loc if (abs(RDV)&gt;=1) {stopper&lt;-1; break} } } else { RDV &lt;- RDV + sum(drift) rt &lt;- rt + firstDur prevLoc &lt;- loc } } ####################################################### # transitions and middle fixations until choice is made while (abs(RDV)&lt;1) { transDur &lt;- sample(transition,1) trans_err &lt;- rnorm(n=transDur, mean=0, sd=s) if (abs(RDV+sum(trans_err))&gt;=1) { for (t in 1:transDur) { RDV &lt;- RDV + trans_err[t] rt &lt;- rt + 1 lastLoc &lt;- prevLoc if (abs(RDV)&gt;=1) {stopper&lt;-1; break} } } else { RDV &lt;- RDV + sum(trans_err) rt &lt;- rt + transDur } if (stopper==0) { middleDur &lt;- sample(middleFix,1) if (prevLoc==1) {loc&lt;-0} if (prevLoc==0) {loc&lt;-1} if (loc==1) {drift_mean &lt;- (d+g*pe)*(vL-t*vR)} if (loc==0) {drift_mean &lt;- (d+g*pe)*(t*vL-vR)} drift &lt;- drift_mean + rnorm(n=middleDur, mean=0, sd=s) if (abs(RDV+sum(drift))&gt;=1) { for (t in 1:middleDur) { RDV &lt;- RDV + drift[t] rt &lt;- rt + 1 lastLoc &lt;- loc if (abs(RDV)&gt;=1) {break} } } else { RDV &lt;- RDV + sum(drift) rt &lt;- rt + middleDur prevLoc &lt;- loc } } } ############################## # return your results if (RDV&gt;0) {choice &lt;- 1} if (RDV&lt;0) {choice &lt;- 0} vDiff &lt;- vL*10-vR*10 results &lt;- data.frame(choice=choice, rt=rt/1000, vL=vL*10, vR=vR*10, vDiff=vDiff, lastFix=lastLoc) return(results) } 3.7.2 Out-of-sample predictions Simulate simCount = 20 set.seed(seed) # fixation data from out-of-sample fixeven &lt;- food[food$Trial%%2==0,] # Placeholders vL &lt;- list() vR &lt;- list() pe &lt;- list() d &lt;- list() g &lt;- list() sig &lt;- list() theta &lt;- list() bias &lt;- list() prFirstLeft &lt;- list() latency &lt;- list() firstFix &lt;- list() transition &lt;- list() middleFix &lt;- list() mem.sim &lt;- data.frame( subj = NA, trial = NA, choice = NA, choice.a = NA, rt = NA, rt.a=NA, vL = NA, vR = NA, vDiff = NA, simulation = NA, lastFix = NA, lastFix.a = NA, pe=NA ) # Loop through subjects to get everyone&#39;s choices and RT for (sub in sort(unique(test$subject))) { # Progress tracker print(sub) # gather relevant data subjdata &lt;- test[test$subject==sub,] vL[[sub]] &lt;- subjdata$v_L vR[[sub]] &lt;- subjdata$v_R pe[[sub]] &lt;- subjdata$pe d.ind &lt;- paste0(&#39;d.&#39;,toString(sub),&#39;.&#39;) g.ind &lt;- paste0(&#39;g.&#39;,toString(sub),&#39;.&#39;) sig.ind &lt;- paste0(&#39;sig.&#39;,toString(sub),&#39;.&#39;) bias.ind &lt;- paste0(&#39;bias.&#39;,toString(sub),&#39;.&#39;) theta.ind &lt;- paste0(&#39;theta.&#39;,toString(sub),&#39;.&#39;) # convert all parameters to 1 ms timestep (originally in 1 s timestep) d[[sub]] &lt;- sample(memtraces[,d.ind], simCount)/1000 g[[sub]] &lt;- sample(memtraces[,g.ind], simCount)/1000 sig[[sub]] &lt;- sample(memtraces[,sig.ind], simCount)/sqrt(1000) bias[[sub]] &lt;- (sample(memtraces[,bias.ind], simCount)-0.5)*2 theta[[sub]] &lt;- sample(memtraces[,theta.ind], simCount) subjfix &lt;- fixeven[fixeven$SubjectNumber==sub,] prFirstLeft[[sub]] &lt;- mean( (subjfix$ROI[subjfix$fixNum==1]==1) ,na.rm=T) latency[[sub]] &lt;- test$ndt #capturing both latency and transitions firstFix[[sub]] &lt;- round(subjfix$DwellLength[subjfix$fixNum==1]*1000,0) transition[[sub]] &lt;- c(0) middleFix[[sub]] &lt;- round(subjfix$DwellLength[subjfix$middleFix==1]*1000,0) # Simulate dataset for (j in 1:simCount) { for (i in 1:length(vL[[sub]])) { simTrial &lt;- mem.sim.trial( b = bias[[sub]][j], d = d[[sub]][j], g = g[[sub]][j], t = theta[[sub]][j], s = sig[[sub]][j], vL = vL[[sub]][i], vR = vR[[sub]][i], pe = pe[[sub]][[i]], prFirstLeft = prFirstLeft[[sub]], latency = latency[[sub]], transition = transition[[sub]], firstFix = firstFix[[sub]], middleFix = middleFix[[sub]] ) asimTrial &lt;- mem.sim.trial( b = bias[[sub]][j], d = d[[sub]][j], g = c(0), # again, aDDM is nested in mem-aDDM (i.e. g=0). t = theta[[sub]][j], s = sig[[sub]][j], vL = vL[[sub]][i], vR = vR[[sub]][i], pe = c(0), prFirstLeft = prFirstLeft[[sub]], latency = latency[[sub]], transition = transition[[sub]], firstFix = firstFix[[sub]], middleFix = middleFix[[sub]] ) simTrial$choice.a &lt;- asimTrial$choice simTrial$rt.a &lt;- asimTrial$rt simTrial$lastFix.a &lt;- asimTrial$lastFix simTrial$subj &lt;- sub simTrial$trial &lt;- i simTrial$simulation &lt;- j simTrial$pe &lt;- pe[[sub]][[i]] mem.sim &lt;- rbind(mem.sim, simTrial) } } } mem.sim &lt;- na.omit(mem.sim) save(mem.sim, file=&quot;temp/mem-aDDM_sim.RData&quot;) I want two plots, each with 3 lines. One plot for choices. One plot for RTs. One line will show true out-of-sample data. One line will show mem-aDDM predictions for those exact same trials. One line will show aDDM predictions for those exact same trials. Run 20 simulations. load(file=&quot;temp/mem-aDDM_sim.RData&quot;) pdata.real &lt;- test %&gt;% group_by(subject, vDiff) %&gt;% summarize( choices = mean(choice, na.rm=T), rts = mean(rt, na.rm=T) ) %&gt;% ungroup() %&gt;% group_by(vDiff) %&gt;% summarize( choice.mean = mean(choices, na.rm=T), choice.se = std.error(choices, na.rm=T), rt.mean = mean(rts, na.rm=T), rt.se = std.error(rts, na.rm=T), Dataset = 0 ) ## `summarise()` has grouped output by &#39;subject&#39;. You can override using the ## `.groups` argument. pdata.real$vDiff &lt;- pdata.real$vDiff*10 pdata.mem &lt;- mem.sim %&gt;% group_by(subj, vDiff) %&gt;% summarize( choices = mean(choice, na.rm=T), rts = mean(rt, na.rm=T) ) %&gt;% ungroup() %&gt;% group_by(vDiff) %&gt;% summarize( choice.mean = mean(choices, na.rm=T), choice.se = std.error(choices, na.rm=T), rt.mean = mean(rts, na.rm=T), rt.se = std.error(rts, na.rm=T), Dataset = 1 ) ## `summarise()` has grouped output by &#39;subj&#39;. You can override using the ## `.groups` argument. pdata.a &lt;- mem.sim %&gt;% group_by(subj, vDiff) %&gt;% summarize( choices = mean(choice.a, na.rm=T), rts = mean(rt.a, na.rm=T) ) %&gt;% ungroup() %&gt;% group_by(vDiff) %&gt;% summarize( choice.mean = mean(choices, na.rm=T), choice.se = std.error(choices, na.rm=T), rt.mean = mean(rts, na.rm=T), rt.se = std.error(rts, na.rm=T), Dataset = 2 ) ## `summarise()` has grouped output by &#39;subj&#39;. You can override using the ## `.groups` argument. pdata &lt;- rbind(pdata.real, pdata.mem) pdata &lt;- rbind(pdata, pdata.a) pdata$Dataset &lt;- factor(pdata$Dataset, levels=c(0,1,2), labels=c(&quot;Data&quot;,&quot;mem-aDDM Sim.&quot;,&quot;aDDM Sim.&quot;)) mem.choice.plot &lt;- ggplot(data=pdata, aes(x=vDiff)) + geom_hline(yintercept=0.5, color=&#39;grey&#39;, alpha=0.75) + geom_vline(xintercept=0, color=&#39;grey&#39;, alpha=0.75) + geom_line(aes(y=choice.mean, group=Dataset, color=Dataset), size=2) + geom_ribbon(aes(ymin=choice.mean-choice.se, ymax=choice.mean+choice.se, group=Dataset, fill=Dataset), alpha=.2) + ylab(&quot;P(choose left)&quot;) + xlab(&quot;Value difference (L-R)&quot;) + ylim(c(0,1)) + theme_classic() + theme( legend.position=c(0.25,.8) ) ## Warning: A numeric `legend.position` argument in `theme()` was deprecated in ggplot2 ## 3.5.0. ## ℹ Please use the `legend.position.inside` argument of `theme()` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. mem.rt.plot &lt;- ggplot(data=pdata, aes(x=vDiff)) + geom_vline(xintercept=0, color=&#39;grey&#39;, alpha=0.75) + geom_line(aes(y=rt.mean, group=Dataset, color=Dataset), size=2) + geom_ribbon(aes(ymin=rt.mean-rt.se, ymax=rt.mean+rt.se, group=Dataset, fill=Dataset), alpha=.2) + ylab(&quot;Response time (s)&quot;) + xlab(&quot;Value difference (L-R)&quot;) + theme_classic() + theme( legend.position=&quot;None&quot; ) grid.arrange( mem.choice.plot, mem.rt.plot, nrow=1 ) 3.7.3 RT with low and high exposure. # Get median pe for each subject and indicators for which obs are for low and high pe. test &lt;- test %&gt;% group_by(subject) %&gt;% mutate( pe.med = median(pe), pe.low = pe &lt;= pe.med, pe.high = pe &gt; pe.med, difficulty = abs(vDiff)*10 #also a difficulty metric ) mem.sim &lt;- mem.sim %&gt;% group_by(subj) %&gt;% mutate( pe.med = median(pe), pe.low = pe &lt;= pe.med, pe.high = pe &gt; pe.med, difficulty = abs(vDiff) #also a difficulty metric ) # real data pdata.real.low &lt;- test[test$pe.low==T,] %&gt;% group_by(subject, difficulty) %&gt;% summarize( rt.mean = mean(rt) ) %&gt;% ungroup() %&gt;% group_by(difficulty) %&gt;% summarize( y = mean(rt.mean), se = std.error(rt.mean), Dataset = &quot;Real&quot;, Exposure = &quot;Low&quot;, group = 1 ) ## `summarise()` has grouped output by &#39;subject&#39;. You can override using the ## `.groups` argument. pdata.real.high &lt;- test[test$pe.high==T,] %&gt;% group_by(subject, difficulty) %&gt;% summarize( rt.mean = mean(rt) ) %&gt;% ungroup() %&gt;% group_by(difficulty) %&gt;% summarize( y = mean(rt.mean), se = std.error(rt.mean), Dataset = &quot;Real&quot;, Exposure = &quot;High&quot;, group = 2 ) ## `summarise()` has grouped output by &#39;subject&#39;. You can override using the ## `.groups` argument. # simulated data pdata.sim.low &lt;- mem.sim[mem.sim$pe.low==T,] %&gt;% group_by(subj, difficulty) %&gt;% summarize( rt.mean = mean(rt) ) %&gt;% ungroup() %&gt;% group_by(difficulty) %&gt;% summarize( y = mean(rt.mean), se = std.error(rt.mean), Dataset = &quot;Simulated&quot;, Exposure = &quot;Low&quot;, group = 3 ) ## `summarise()` has grouped output by &#39;subj&#39;. You can override using the ## `.groups` argument. pdata.sim.high &lt;- mem.sim[mem.sim$pe.high==T,] %&gt;% group_by(subj, difficulty) %&gt;% summarize( rt.mean = mean(rt) ) %&gt;% ungroup() %&gt;% group_by(difficulty) %&gt;% summarize( y = mean(rt.mean), se = std.error(rt.mean), Dataset = &quot;Simulated&quot;, Exposure = &quot;High&quot;, group = 4 ) ## `summarise()` has grouped output by &#39;subj&#39;. You can override using the ## `.groups` argument. pdata &lt;- bind_rows(pdata.real.low, pdata.real.high, pdata.sim.low, pdata.sim.high) exposure.rt.plot &lt;- ggplot(data=pdata, aes(x=difficulty)) + geom_line(aes(y=y, group=group, color=Dataset, linetype=Exposure), size=2) + geom_ribbon(aes(ymin=y-se, ymax=y+se, group=group, fill=Dataset), alpha=.2) + ylab(&quot;Response time (s)&quot;) + xlab(&quot;Best - worst value&quot;) + theme_classic() exposure.rt.plot References "],["memDDM.html", "Chapter 4 memDDM 4.1 Introduction 4.2 Methods 4.3 Behavioral Results 4.4 Fit with PyDDM 4.5 Simulations 4.6 Compare simulations and data", " Chapter 4 memDDM (TL;DR) I attempt to incorporate working memory (mem-) into a exponential collapsing bounds Drift-Diffusion-Model (DDM). The exponential bounds add two new parameters to the DDM, delay before collapse and rate of collapse. I hypothesized that the delay before the collapse will inversely scale with previous encounters with either stimuli (call this “familiarity”). In other words, people will make less patient decisions when they are more familiar with the stimuli. I tested this out by setting delay equal to \\(t_0 + \\gamma \\text{Familiarity}\\), where \\(t_0\\) is a baseline collapse delay and \\(\\gamma&lt;0\\) is how much the delay is scaled by familiarity. I found \\(t_0=8.4\\), similar to the delay estimate from a standard collapsing bound DDM. Furthermore, I found \\(\\gamma=-0.8\\), indicating that patience is inversely scaled in familiarity with the stimuli. Unfortunately, predictions from this memDDM are not a good qualitative match with response time patterns observed in the data. 4.1 Introduction Like in the last chapter, I’m trying to model faster response times in response to repeated exposure to stimuli. I tried incorporating a drift rate that scales with the number of previous exposures to the chosen option. That didn’t work. Ya boi is at it again, except this time, I hypothesize that the time when decision bounds start collapsing is modulated by the number of previous encounters with either option. Specifically, using the functional form laid out by (Hawkins et al. 2015), I hypothesize that the shape parameter (\\(\\kappa\\)) is inversely proportional to the number of previous exposures. Note that here, I am using a Generalized Drift-Diffusion-Model (Shinn, Lam, and Murray 2020), not an aDDM. This is for 2 reasons: I want some practice with fitting the GDDM using the PyDDM package. I want to see how flexible the parameters of the GDDM are. It’ll probably be faster to estimate than an aDDM, which appeases my currently tight schedule. Similar to the last chapter, the goals of this report are to: Incorporate the idea that internal samples are modulated by (and sometimes even sampled from) memory into a sequential sampling model. Build a variation of the DDM that explains shorter response times with more familiar stimuli. 4.2 Methods Reading and transforming the data from (Smith and Krajbich 2018). 4.2.1 Prep work 4.2.1.1 Load libraries rm(list = ls()) seed = 1337 library(dplyr) library(ggplot2) library(hrbrthemes) library(ggsci) library(data.table) library(plotrix) library(grid) library(gridExtra) library(reticulate) #use_python(&quot;D:/Program Files/PsychoPy/python.exe&quot;) 4.2.1.2 Load data I will again be using the data from (Smith and Krajbich 2018). The data can be downloaded here: https://osf.io/x2jhp/?view_only=2669d8f3983d4442952a52c5de5814f7. I calculate a variable called “PreviousEncounterBoth”, which counts the number of previous trials in which the subject has seen either item for this trial. Familiarity is low or high. Low means previous encounters with either item is below or equal to median for that subject. High means previous exposures is above median. load(&quot;data/mem-aDDM-smithkrajbich2018.RData&quot;) twofoodeyedata &lt;- twofoodeyedata %&gt;% group_by(SubjectNumber, Trial) %&gt;% mutate( # fixation number fixNum=row_number() ) # Running counts of the number of times the subjects have seen the left and right options across previous trials twofoodchoicedata$PreviousEncounterLeft &lt;- NA twofoodchoicedata$PreviousEncounterRight &lt;- NA data &lt;- twofoodchoicedata[order(twofoodchoicedata$SubjectNumber, twofoodchoicedata$Trial),] for (n in 1:length(data$SubjectNumber)) { tempdata &lt;- data[data$SubjectNumber==data$SubjectNumber[n] &amp; data$Trial&lt;=data$Trial[n],] prevList &lt;- rbind(tempdata$FoodLeft,tempdata$FoodRight) data$PreviousEncounterLeft[n] &lt;- sum(prevList==data$FoodLeft[n])-1 data$PreviousEncounterRight[n] &lt;- sum(prevList==data$FoodRight[n])-1 } data$PreviousEncounterBoth &lt;- data$PreviousEncounterLeft+data$PreviousEncounterRight data$PreviousEncounterChosen &lt;- ifelse(data$LeftRight==1, data$PreviousEncounterLeft, data$PreviousEncounterRight) data &lt;- data %&gt;% group_by(SubjectNumber) %&gt;% mutate( pe.median = median(PreviousEncounterBoth), Familiarity = ifelse(PreviousEncounterBoth &gt; pe.median, 1, 0) %&gt;% factor(levels=c(0,1), labels=c(&quot;Low&quot;,&quot;High&quot;)), vdiff = ValueLeft-ValueRight, difficulty = abs(ValueLeft-ValueRight), LeftRight = ifelse(LeftRight==1, 1,0) ) write.csv(data, &quot;data/mem-DDM-cleanSmithKrajbich2018.csv&quot;) 4.3 Behavioral Results What do choices and response times look like? This is what I’m trying to model. 4.3.1 Choice probabilities Probability of choosing the left option wrt value differences. pdata.choice &lt;- data %&gt;% group_by(SubjectNumber, vdiff) %&gt;% summarize( choice.means = mean(LeftRight) ) %&gt;% ungroup() %&gt;% group_by(vdiff) %&gt;% summarize( y = mean(choice.means), se = std.error(choice.means) ) plot.choice &lt;- ggplot(data=pdata.choice, aes(x=vdiff, y=y)) + geom_vline(xintercept=0, color=&quot;grey&quot;, alpha=.75) + geom_hline(yintercept=0.5, color=&quot;grey&quot;, alpha=.75) + geom_line(size=2) + geom_ribbon(aes(ymin=y-se, ymax=y+se), alpha=.25) + labs(y=&quot;Pr(choose left)&quot;, x=&quot;Left - right rating&quot;) + theme_classic() plot.choice 4.3.2 RTs, grouped by familiarity. This is the phenomenon I am trying to model with the GDDM. Response times across difficulties are shorter when the subject is more familiar with both stimuli. pdata.rt &lt;- data %&gt;% group_by(SubjectNumber, Familiarity, difficulty) %&gt;% summarize( RT.means = mean(RT) ) %&gt;% ungroup() %&gt;% group_by(Familiarity, difficulty) %&gt;% summarize( y = mean(RT.means), se = std.error(RT.means) ) plot.rt &lt;- ggplot(data=pdata.rt, aes(x=difficulty, y=y, group=Familiarity, color=Familiarity)) + geom_line(size=2) + geom_ribbon(aes(ymin=y-se, ymax=y+se, fill=Familiarity), alpha=.25) + labs(y=&quot;Response times (s)&quot;, x=&quot;Best - worst rating&quot;) + theme_classic() plot.rt 4.4 Fit with PyDDM I will use PyDDM by (Shinn, Lam, and Murray 2020) to fit a GDDM to the data. 4.4.1 Libraries and reading in the data from ddm import Model, Fittable, Sample, Bound, set_N_cpus, FitResult from ddm.functions import fit_adjust_model, display_model, fit_adjust_model from ddm.models import NoiseConstant, BoundConstant, BoundCollapsingExponential, OverlayChain, OverlayNonDecision, OverlayPoissonMixture, LossRobustBIC import ddm.plot import math import pandas as pd import numpy as np set_N_cpus(4) # read in csv data with open(&quot;data/mem-DDM-cleanSmithKrajbich2018.csv&quot;, &quot;r&quot;) as f: df_rt = pd.read_csv(f) df_rt = df_rt[df_rt[&quot;SubjectNumber&quot;]==1] sk_sample = Sample.from_pandas_dataframe(df_rt, rt_column_name=&quot;RT&quot;, correct_column_name=&quot;LeftRight&quot;) 4.4.2 Standard DDM Fix noise = 1. Why noise? We are going to fit collapsing bounds later, so need to fix something else. Noise is a more traditional candidate than drift rate as a fixed parameter. # Let drift rate vary with value difference class DriftScaled(ddm.models.Drift): name = &quot;Drift depends linearly on value difference&quot; required_parameters = [&quot;driftvaluediff&quot;] required_conditions = [&quot;vdiff&quot;] def get_drift(self, conditions, **kwargs): return self.driftvaluediff * conditions[&quot;vdiff&quot;] # fit the data model_sk = Model( name = &#39;SmithKrajbich2018 data, drift varies with value difference&#39;, drift = DriftScaled( driftvaluediff = Fittable(minval=0, maxval=2) ), noise = NoiseConstant(noise = 1), bound = BoundConstant(B=Fittable(minval=.1, maxval=1.5)), overlay=OverlayChain( overlays=[ OverlayNonDecision(nondectime = Fittable(minval=0, maxval=1)), OverlayPoissonMixture(pmixturecoef=.02,rate=1) ] ), dx=.01, dt=.01, T_dur=10 ) fit_model_sk_standard = fit_adjust_model( sample = sk_sample, model = model_sk, lossfunction = LossRobustBIC, verbose=False) display_model(fit_model_sk_standard) with open(&quot;temp/memDDM-standard.txt&quot;, &quot;w&quot;) as f: f.write(repr(fit_model_sk_standard)) 4.4.3 mem-DDM where drift scales with previous exposure to the chosen option Just double checking that we get similar DDM parameters to the previous chapter, even though we aren’t accounting for attentional biases here. # Let drift rate vary with value difference and previous exposure to the chosen item class DriftScaled(ddm.models.Drift): name = &quot;Drift depends linearly on value difference&quot; required_parameters = [&quot;driftvaluediff&quot;,&quot;driftprevexp&quot;] required_conditions = [&quot;vdiff&quot;,&quot;PreviousEncounterChosen&quot;] def get_drift(self, conditions, **kwargs): return (self.driftvaluediff + self.driftprevexp * conditions[&quot;PreviousEncounterChosen&quot;]) * conditions[&quot;vdiff&quot;] # fit the data model_sk = Model( name = &#39;SmithKrajbich2018 data, drift varies with value difference&#39;, drift = DriftScaled( driftvaluediff = Fittable(minval=0, maxval=2), driftprevexp = Fittable(minval=0, maxval=2) ), noise = NoiseConstant(noise = 1), bound = BoundConstant(B=Fittable(minval=.1, maxval=1.5)), overlay=OverlayChain( overlays=[ OverlayNonDecision(nondectime = Fittable(minval=0, maxval=1)), OverlayPoissonMixture(pmixturecoef=.02,rate=1) ] ), dx=.01, dt=.01, T_dur=10 ) fit_model_sk_driftScaled = fit_adjust_model( sample = sk_sample, model = model_sk, lossfunction = LossRobustBIC, verbose=False) display_model(fit_model_sk_driftScaled) with open(&quot;temp/memDDM-dirftScaled.txt&quot;, &quot;w&quot;) as f: f.write(repr(fit_model_sk_driftScaled)) Good news everyone! Drift rate, accounting for wider boundaries, is in the same ballpark as before. 4.4.4 DDM with collpasing bounds Using exponential bounds to speed up fitting. Faster than (Hawkins et al. 2015) Weibull CDF since it has fewer parameters. After some conversations with Daeyeol Lee in Lake Arrowhead 2020, it also doesn’t seem like it makes much difference what the functional form of the collapsing bounds is. In terms of predictive accuracy, they don’t make much difference. Since this is just early exploration and isn’t going out to any peer-reviewed journals… why not just go with the faster functional form? # Let drift rate vary with value difference class DriftRate(ddm.models.Drift): name = &quot;Drift depends linearly on value difference&quot; required_parameters = [&quot;driftvaluediff&quot;] required_conditions = [&quot;vdiff&quot;] def get_drift(self, conditions, **kwargs): return self.driftvaluediff * conditions[&quot;vdiff&quot;] # Let bounds collapse after a certain delay class BoundCollapsingExponentialDelay(Bound): &quot;&quot;&quot;Bound collapses exponentially over time. Takes three parameters: `B` - the bound at time t = 0. `tau` - the time constant for the collapse, should be greater than zero. `t1` - the time at which the collapse begins, in seconds &quot;&quot;&quot; name = &quot;Delayed exponential collapsing bound&quot; required_parameters = [&quot;B&quot;, &quot;tau&quot;, &quot;t1&quot;] def get_bound(self, t, conditions, **kwargs): if t &lt;= self.t1: return self.B if t &gt; self.t1: return self.B * np.exp(-self.tau*(t-self.t1)) # fit the data model_sk = Model( name = &#39;SmithKrajbich2018 data, drift varies with value difference&#39;, drift = DriftRate(driftvaluediff = Fittable(minval=0, maxval=2)), noise = NoiseConstant(noise = 1), bound = BoundCollapsingExponentialDelay( B = Fittable(minval=.1, maxval=1.5), tau = Fittable(minval=.1, maxval=5), t1 = Fittable(minval=0, maxval=10) ), overlay=OverlayChain( overlays=[ OverlayNonDecision(nondectime = Fittable(minval=0, maxval=1)), OverlayPoissonMixture(pmixturecoef=.02,rate=1) ] ), dx=.01, dt=.01, T_dur=10 ) fit_model_sk_collapseBound = fit_adjust_model( sample = sk_sample, model = model_sk, lossfunction = LossRobustBIC, verbose=False) display_model(fit_model_sk_collapseBound) with open(&quot;temp/memDDM-collapseBound.txt&quot;, &quot;w&quot;) as f: f.write(repr(fit_model_sk_collapseBound)) Drift rate = 0.35 Noise = 1 Boundary starting point = 1.3 Boundary delay = 8.4 Rate of collapse = 1.9 Non-decision time = 0.6 4.4.5 mem-DDM where boundary collapse shape scales with previous exposure to both items Using exponential bounds where delay is scaled by previous exposure to both items. # Let drift rate vary with value difference class DriftRate(ddm.models.Drift): name = &quot;Drift depends linearly on value difference&quot; required_parameters = [&quot;driftvaluediff&quot;] required_conditions = [&quot;vdiff&quot;] def get_drift(self, conditions, **kwargs): return self.driftvaluediff * conditions[&quot;vdiff&quot;] # Let bounds collapse after a certain delay scaled by previous exposure class BoundCollapsingExponentialDelay(Bound): &quot;&quot;&quot;Bound collapses exponentially over time. Takes three parameters: `B` - the bound at time t = 0. `tau` - the time constant for the collapse, should be greater than zero. `t1` - the time at which the collapse begins, in seconds `gam` - how does delay scale with previous exposure to both options &quot;&quot;&quot; name = &quot;Delayed exponential collapsing bound&quot; required_parameters = [&quot;B&quot;, &quot;tau&quot;, &quot;t1&quot;, &quot;gam&quot;] required_conditions = [&quot;PreviousEncounterBoth&quot;] def get_bound(self, t, conditions, **kwargs): scaledDelay = self.t1 + self.gam * conditions[&quot;PreviousEncounterBoth&quot;] if t &lt;= scaledDelay: return self.B if t &gt; scaledDelay: return self.B * np.exp(-self.tau*(t-scaledDelay)) # fit the data model_sk = Model( name = &#39;SmithKrajbich2018 data, drift varies with value difference&#39;, drift = DriftRate(driftvaluediff = Fittable(minval=.2, maxval=.5)), noise = NoiseConstant(noise = 1), bound = BoundCollapsingExponentialDelay( B = Fittable(minval=1, maxval=1.4), tau = Fittable(minval=.1, maxval=3), t1 = Fittable(minval=0, maxval=10), gam = Fittable(minval=-10, maxval=10) ), overlay=OverlayChain( overlays=[ OverlayNonDecision(nondectime = Fittable(minval=0, maxval=1)), OverlayPoissonMixture(pmixturecoef=.02,rate=1) ] ), dx=.01, dt=.01, T_dur=10 ) fit_model_sk_collapseBoundScaled = fit_adjust_model( sample = sk_sample, model = model_sk, lossfunction = LossRobustBIC, verbose=False) display_model(fit_model_sk_collapseBoundScaled) with open(&quot;temp/memDDM-boundsScaled-additive.txt&quot;, &quot;w&quot;) as f: f.write(repr(fit_model_sk_collapseBoundScaled)) Drift rate = 0.37 Noise = 1 Boundary starting point = 1.3 Boundary delay with no familiarity = 8.4 Familiarity linearly scales boundary delay = -0.8 Rate of collapse = 2.6 Non-decision time = 0.6 4.5 Simulations Simulating the memDDM to see if it can predict the behavior we see in the data. 4.5.1 Read the stored models with open(&quot;temp/memDDM-standard.txt&quot;, &quot;r&quot;) as f: fit_model_sk_standard = eval(f.read()) with open(&quot;temp/memDDM-boundsScaled-additive.txt&quot;, &quot;r&quot;) as f: fit_model_sk_collapseBoundScaled = eval(f.read()) 4.5.2 Define a function to get mean response time. This will be for a given a value difference and previous encounter since that’s how the simulations are generated. def get_rt(solutionObj, modelObj): return( # top: mean RT for left choices * probability of left # bottom: mean RT for right choices * probability of right np.mean( sum(solutionObj.corr*modelObj.t_domain()) + sum(solutionObj.err*modelObj.t_domain()) ) ) 4.5.3 Simulate choices and response times Use unique combinations of value difference and previous encounters with both stimuli from the data. conditions = [&quot;PreviousEncounterBoth&quot;,&quot;vdiff&quot;] pe_unique = np.unique(df_rt[conditions[0]]) vdiff_unique = np.unique(df_rt[conditions[1]]) nObs = len(pe_unique)*len(vdiff_unique) placeholder = np.repeat(0.0, nObs) df_sim_standard = pd.DataFrame( data = np.matrix([placeholder, placeholder, placeholder, placeholder]).T, columns = [&quot;vdiff&quot;,&quot;pe&quot;,&quot;choice&quot;,&quot;rt&quot;] ) df_sim_CBS = pd.DataFrame( data = np.matrix([placeholder, placeholder, placeholder, placeholder]).T, columns = [&quot;vdiff&quot;,&quot;pe&quot;,&quot;choice&quot;,&quot;rt&quot;] ) ind = -1 for vd in vdiff_unique: for pe in pe_unique: ind = ind + 1 sol_standard = fit_model_sk_standard.solve( conditions = { &quot;vdiff&quot;:vd, &quot;PreviousEncounterBoth&quot;:pe } ) df_sim_standard[&quot;vdiff&quot;][ind] = vd df_sim_standard[&quot;pe&quot;][ind] = pe df_sim_standard[&quot;choice&quot;][ind] = sol_standard.prob_correct() df_sim_standard[&quot;rt&quot;][ind] = get_rt(sol_standard, model_sk) sol_collapseBoundScaled = fit_model_sk_collapseBoundScaled.solve( conditions = { &quot;vdiff&quot;:vd, &quot;PreviousEncounterBoth&quot;:pe } ) df_sim_CBS[&quot;vdiff&quot;][ind] = vd df_sim_CBS[&quot;pe&quot;][ind] = pe df_sim_CBS[&quot;choice&quot;][ind] = sol_collapseBoundScaled.prob_correct() df_sim_CBS[&quot;rt&quot;][ind] = get_rt(sol_collapseBoundScaled, model_sk) df_sim_standard.to_csv(&quot;temp/memDDM-sim-standard.csv&quot;) df_sim_CBS.to_csv(&quot;temp/memDDM-sim-collapseBoundScaled.csv&quot;) 4.6 Compare simulations and data 4.6.1 Choices #sim.DDM &lt;- read.csv(&quot;temp/memDDM-sim-standard.csv&quot;) sim.memDDM &lt;- read.csv(&quot;temp/memDDM-sim-collapseBoundScaled.csv&quot;) # sim.DDM &lt;- sim.DDM %&gt;% # group_by(vdiff) %&gt;% # summarize( # y = mean(choice), # Dataset = &quot;DDM&quot;, # se = NA # ) sim.memDDM &lt;- sim.memDDM %&gt;% group_by(vdiff) %&gt;% summarize( y = mean(choice), Dataset = &quot;memDDM&quot;, se = NA ) pdata.choice$Dataset &lt;- &quot;Data&quot; pdata.compare.choice &lt;- bind_rows(sim.memDDM, pdata.choice) plot.compare.choice &lt;- ggplot(data=pdata.compare.choice, aes(x=vdiff, y=y, color=Dataset, linetype=Dataset)) + geom_vline(xintercept=0, color=&quot;grey&quot;, alpha=.75) + geom_hline(yintercept=0.5, color=&quot;grey&quot;, alpha=.75) + geom_line(size=2) + geom_ribbon(aes(ymin=y-se, ymax=y+se, fill=Dataset), alpha=.25) + labs(y=&quot;Pr(choose left)&quot;, x=&quot;Left - right rating&quot;) + theme_classic() + scale_color_futurama() + scale_fill_futurama() plot.compare.choice The memDDM does quite a poor job with predicting choices. 4.6.2 RTs #sim.DDM &lt;- read.csv(&quot;temp/memDDM-sim-standard.csv&quot;) sim.memDDM &lt;- read.csv(&quot;temp/memDDM-sim-collapseBoundScaled.csv&quot;) pe.med &lt;- as.numeric(unique(data[data$SubjectNumber==1,]$pe.median)) # sim.DDM &lt;- sim.DDM %&gt;% # mutate( # Familiarity = factor( # ifelse(pe&gt;pe.med, 1, 0), # levels=c(0,1), # labels=c(&quot;Low&quot;,&quot;High&quot;) # ), # difficulty = abs(vdiff) # ) %&gt;% # group_by(difficulty, Familiarity) %&gt;% # summarize( # y = mean(rt), # se = NA, # Dataset = &quot;DDM&quot; # ) sim.memDDM &lt;- sim.memDDM %&gt;% mutate( pe.med = pe.med, Familiarity = factor( ifelse(pe&gt;pe.med, 1, 0), levels=c(0,1), labels=c(&quot;Low&quot;,&quot;High&quot;) ), difficulty = abs(vdiff) ) %&gt;% group_by(difficulty, Familiarity) %&gt;% summarize( y = mean(rt), se = NA, Dataset = &quot;memDDM&quot; ) pdata.rt$Dataset &lt;- &quot;Data&quot; pdata.compare.rt &lt;- bind_rows(sim.memDDM, pdata.rt) plot.compare.rt &lt;- ggplot(data=pdata.compare.rt, aes(x=difficulty, y=y, color=Familiarity, linetype=Dataset)) + geom_line(size=2) + geom_ribbon(aes(ymin=y-se, ymax=y+se, fill=Familiarity), alpha=.25) + labs(y=&quot;Response time (s)&quot;, x=&quot;Best - worst rating&quot;) + theme_classic() plot.compare.rt For high difficulty trials, looks like we can get slight downward shifts in response time with high familiarity. This difference gradually falls to 0 as trials get easier. Predictions are nowhere near observed response times at higher difficulties. It seems that boundary collapse delay scaled by repeated encounters with both stimuli is unable to generate the level shifts in response time with familiarity that we see in data. References "],["ddm-first-order-stochastic-dominance.html", "Chapter 5 DDM &amp; First-Order Stochastic Dominance 5.1 The DDM Can Explain Violations of First-Order Stochastic Dominance 5.2 Preamble 5.3 DDM Simulation Function 5.4 Lotteries 5.5 Single Agent Simulations 5.6 Multi-Agent Simulations", " Chapter 5 DDM &amp; First-Order Stochastic Dominance 5.1 The DDM Can Explain Violations of First-Order Stochastic Dominance Author: Brenden Eum (2024) This notebook is for Charly Hervy at UPF in Barcelona. She finds that some of her subjects violate first-order stochastic dominance (FOSD) in a risky choice task. I argue that this can be modeled by the Drift-Diffusion-Model (DDM) from cognitive neuroscience. It is one of the most famous models to come out of this literature, cited in literally over a million papers (also goes by “Diffusion Decision Model”, so named by members of the Psychology and Economics departments at OSU). The model considers the speed-accuracy trade-off in decisions, and therefore requires data on both choices and response times. Larbi might like this idea since he has a working paper on response times, I believe. The intuition behind the model is this: (1) If two options are similarly valued, the decision is hard, takes more time, and is made with a higher error rate. (2) As the difference in value between the two options grows, the decision becomes easier, takes less time, and is made with a lower error rate. There is an element of stochasticity in choices that originates from evidence in neuroscience, but is implemented in a very simple manner in the DDM. This stochasticity is the source of errors in decisions, and is one of TWO features of the DDM that may explain violations of FOSD. I’ll only focus on this feature here. Patrick is aware of the model too, so I’m sure he can help if I failed to clearly explain the intuition here. In the past, the DDM (and the class of models it belongs to called “sequential sampling models”) has been used to explain preference reversals, violations of transitivity, non-linear probability reweighting, etc. (Tsetsos et al. 2012, Testsos et al. 2016, Zilker and Pachur 2022). While I’m not alone in thinking that it can be used to explain violations of FOSD, nobody has actually collected data to test this (I asked around to see if it had been done). I think (a) the DDM may offer a potential explanation of your data, and (b) your experiment may offer something novel for the DDM literature. If you add a paragraph or small section on response time patterns, expected value differences, and the DDM, I can spread the word to all the sequential sampling modelers + neuroeconomists, and you may get citations from the psychology and neuroscience fields too! 5.2 Preamble rm(list=ls()) set.seed(4) library(tidyverse) ## ── Attaching core tidyverse packages ──────────────────── tidyverse 2.0.0 ── ## ✔ forcats 1.0.0 ✔ stringr 1.5.1 ## ✔ lubridate 1.9.3 ✔ tibble 3.2.1 ## ✔ purrr 1.0.2 ✔ tidyr 1.3.1 ## ✔ readr 2.1.5 ## ── Conflicts ────────────────────────────────────── tidyverse_conflicts() ── ## ✖ data.table::between() masks dplyr::between() ## ✖ gridExtra::combine() masks dplyr::combine() ## ✖ tidyr::extract() masks runjags::extract() ## ✖ dplyr::filter() masks stats::filter() ## ✖ data.table::first() masks dplyr::first() ## ✖ lubridate::hour() masks data.table::hour() ## ✖ lubridate::isoweek() masks data.table::isoweek() ## ✖ dplyr::lag() masks stats::lag() ## ✖ data.table::last() masks dplyr::last() ## ✖ lubridate::mday() masks data.table::mday() ## ✖ lubridate::minute() masks data.table::minute() ## ✖ lubridate::month() masks data.table::month() ## ✖ lubridate::quarter() masks data.table::quarter() ## ✖ lubridate::second() masks data.table::second() ## ✖ MASS::select() masks dplyr::select() ## ✖ purrr::transpose() masks data.table::transpose() ## ✖ lubridate::wday() masks data.table::wday() ## ✖ lubridate::week() masks data.table::week() ## ✖ lubridate::yday() masks data.table::yday() ## ✖ lubridate::year() masks data.table::year() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors library(patchwork) ## ## Attaching package: &#39;patchwork&#39; ## ## The following object is masked from &#39;package:MASS&#39;: ## ## area library(plotrix) 5.3 DDM Simulation Function Simulate the DDM for a single trial. Simulation will stop and report NA if subject takes longer than 2 minutes for a single trial simulate_ddm &lt;- function(evidence, a = 1.0, d = 0.001, s = 0.03, b = 0.0, c = 0.0, ts_size = 10, rt_max = 120000) { bounds = a rdv_t = b inside_bounds = T timestep = 0 while(inside_bounds==T &amp; timestep&lt;(rt_max/ts_size)) { rdv_t = rdv_t + d * evidence rdv_t = rdv_t + rnorm(1, 0, s) timestep = timestep + 1 if (abs(rdv_t)&gt;=bounds) {inside_bounds = F} rdv_t_1 = rdv_t } if (rdv_t &gt;= bounds) {choice = 1} if (rdv_t &lt;= bounds) {choice = 0} rt = timestep * ts_size if (rt &gt;= rt_max) {choice = NA} return(list(choice=choice, rt=rt)) } 5.4 Lotteries Generate vectors of lotteries. Lottery L will FOSD Lottery R. L_prb = sample(c(2:99), 100, replace=T)/100 L_amt = sample(c(5:8), 100, replace=T) R_prb = rep(NA, 100) R_amt = rep(NA, 100) for (i in 1:100) { R_prb[i] = sample(c(1:(L_prb[i]*100-1)), 1, replace=T)/100 R_amt[i] = sample(c(1:(L_amt[i]-1)), 1, replace=T) } 5.4.1 Expected Value There are different ways to compare the lotteries. (Not Recommended) Since the DDM is a sequential sampling model, the order in which information (attribute values) enter into the decision process matters (Yang and Krajbich 2023, Fisher 2021). That being said, this would require eye-tracking and a whole bunch of other assumptions, so it may not be the simple explanation you’re looking for. (Recommended) You can just compare the expected values of the lotteries (Eum et al. 2024). pdata = data.frame(L_lottery = &quot;L&quot;, L_ev = L_prb*L_amt, R_lottery = &quot;R&quot;, R_ev = R_prb*R_amt) ggplot(pdata) + geom_segment(aes(x = L_lottery, xend = R_lottery, y = L_ev, yend = R_ev), color = &quot;black&quot;, size = .5, alpha = .2) + geom_point(aes(x = L_lottery, y = L_ev), color = &quot;dodgerblue&quot;, size=.75) + geom_point(aes(x = R_lottery, y = R_ev), color = &quot;darkred&quot;, size=.75) + theme_classic() + labs(y = &quot;Expected Value&quot;, x = &quot;Lottery&quot;, title = &quot;All slopes are strictly negative, indicating FOSD.&quot;) 5.5 Single Agent Simulations 5.5.1 Single Agent Take a single DDM agent with default parameters. What is the rate at which they violate FOSD? single_agent = data.frame() evidence = pdata$L_ev - pdata$R_ev for (i in 1:length(evidence)) { single_trial = simulate_ddm(evidence[i]) %&gt;% data.frame() single_trial$evidence = evidence[i] single_agent = bind_rows(single_agent, single_trial) } # Some cleaning single_agent$rnd_evid = single_agent$evidence %&gt;% round() single_agent$error = ifelse(single_agent$choice==1, 0, 1) 5.5.2 Expected Value Differences and Error Rate pdata.error_ev = single_agent %&gt;% group_by(rnd_evid) %&gt;% summarize(error = mean(error)) ggplot(pdata.error_ev, aes(x=rnd_evid, y=error)) + geom_line(size = 2) + theme_bw() + labs(y = &quot;Rate of Violations of FOSD&quot;, x = &quot;Rounded Expected Value Difference (L-R)&quot;) + coord_cartesian(ylim=c(0,1)) 5.5.3 Response Times and Value Differences. It’s well established in the literature that response times will increase as Expected Value Differences go to 0 (see Forstmann et al. 2016 for a great review). This is typically replicated in every dataset that wants to explain data with DDM since it’s so robust. Think of it as a sanity check that the model can be applied to this data. pdata.rt_ev = single_agent %&gt;% group_by(rnd_evid) %&gt;% summarize(rt = mean(rt)/1000) ggplot(pdata.rt_ev, aes(x=rnd_evid, y=rt)) + geom_line(size = 2) + theme_bw() + labs(y = &quot;Response Time (Seconds)&quot;, x = &quot;Rounded Expected Value Difference (L-R)&quot;) + coord_cartesian(ylim=c(0,NA)) 5.6 Multi-Agent Simulations 5.6.1 Distributions of agents Suppose we have N agents who make decisions using DDM. Draw their parameters from some reasonable distribution, given previous literature. I’ll work off of my last paper (Eum et al. 2023). This may take a few seconds to a minute depending on your computer. N = 100 multi_agent = data.frame() for (n in 1:N) { # Together, the drift rate and noise determine signal-to-noise ratio in this decision process. d = runif(1, min=0.0001, max=0.009) # drift rate s = runif(1, min=0.01, max=0.09) # noise agent_n = data.frame() for (i in 1:length(evidence)) { # Evidence vector is same as in above cells. single_trial = simulate_ddm(evidence[i], d=d, s=s) %&gt;% data.frame() single_trial$evidence = evidence[i] agent_n = bind_rows(agent_n, single_trial) } # Some cleaning agent_n$n = n agent_n$rnd_evid = agent_n$evidence %&gt;% round() agent_n$error = ifelse(agent_n$choice==1, 0, 1) # Combine into placeholder multi_agent = bind_rows(multi_agent, agent_n) } 5.6.2 Expected Value Differences and Error Rate This is the main dish. What you came to see. ARE YOU NOT ENTERTAINED?! It works!!! Let’s plot the mean and standard deviation across the MEANS of the agents. pdata.multi_error_ev = multi_agent %&gt;% group_by(n, rnd_evid) %&gt;% summarize(error = mean(error, na.rm=T)) %&gt;% group_by(rnd_evid) %&gt;% summarize( sd = sd(error, na.rm=T), error = mean(error, na.rm=T) ) ## `summarise()` has grouped output by &#39;n&#39;. You can override using the ## `.groups` argument. ggplot(pdata.multi_error_ev, aes(x=rnd_evid, y=error)) + geom_line(size=1.5) + geom_errorbar(aes(ymin = pmax(error-sd,0), ymax=error+sd), width=0, size=1.5) + theme_bw() + labs(y = &quot;Rate of Violations of FOSD (SD Errorbars)&quot;, x = &quot;Rounded Expected Value Difference (L-R)&quot;) + coord_cartesian(ylim=c(0,1)) "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
